"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-to-jsx-runtime@2.3.6";
exports.ids = ["vendor-chunks/hast-util-to-jsx-runtime@2.3.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/hast-util-to-jsx-runtime@2.3.6/node_modules/hast-util-to-jsx-runtime/lib/index.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-jsx-runtime@2.3.6/node_modules/hast-util-to-jsx-runtime/lib/index.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toJsxRuntime: () => (/* binding */ toJsxRuntime)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! comma-separated-tokens */ \"(ssr)/./node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(ssr)/./node_modules/.pnpm/estree-util-is-identifier-name@3.0.0/node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(ssr)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/.pnpm/property-information@7.0.0/node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/.pnpm/property-information@7.0.0/node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/.pnpm/property-information@7.0.0/node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! space-separated-tokens */ \"(ssr)/./node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var style_to_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-to-js */ \"(ssr)/./node_modules/.pnpm/style-to-js@1.1.16/node_modules/style-to-js/cjs/index.js\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/.pnpm/unist-util-position@5.0.0/node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @import {Identifier, Literal, MemberExpression} from 'estree'\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\n * @import {Position} from 'unist'\n * @import {Child, Create, Field, JsxElement, State, Style} from './types.js'\n */ \n\n\n\n\n\n\n\n\n// To do: next major: `Object.hasOwn`.\nconst own = {}.hasOwnProperty;\n/** @type {Map<string, number>} */ const emptyMap = new Map();\nconst cap = /[A-Z]/g;\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set([\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tfoot\",\n    \"tr\"\n]);\nconst tableCellElement = new Set([\n    \"td\",\n    \"th\"\n]);\nconst docs = \"https://github.com/syntax-tree/hast-util-to-jsx-runtime\";\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JsxElement}\n *   JSX element.\n */ function toJsxRuntime(tree, options) {\n    if (!options || options.Fragment === undefined) {\n        throw new TypeError(\"Expected `Fragment` in options\");\n    }\n    const filePath = options.filePath || undefined;\n    /** @type {Create} */ let create;\n    if (options.development) {\n        if (typeof options.jsxDEV !== \"function\") {\n            throw new TypeError(\"Expected `jsxDEV` in options when `development: true`\");\n        }\n        create = developmentCreate(filePath, options.jsxDEV);\n    } else {\n        if (typeof options.jsx !== \"function\") {\n            throw new TypeError(\"Expected `jsx` in production options\");\n        }\n        if (typeof options.jsxs !== \"function\") {\n            throw new TypeError(\"Expected `jsxs` in production options\");\n        }\n        create = productionCreate(filePath, options.jsx, options.jsxs);\n    }\n    /** @type {State} */ const state = {\n        Fragment: options.Fragment,\n        ancestors: [],\n        components: options.components || {},\n        create,\n        elementAttributeNameCase: options.elementAttributeNameCase || \"react\",\n        evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n        filePath,\n        ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n        passKeys: options.passKeys !== false,\n        passNode: options.passNode || false,\n        schema: options.space === \"svg\" ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n        stylePropertyNameCase: options.stylePropertyNameCase || \"dom\",\n        tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n    };\n    const result = one(state, tree, undefined);\n    // JSX element.\n    if (result && typeof result !== \"string\") {\n        return result;\n    }\n    // Text node or something that turned into nothing.\n    return state.create(tree, state.Fragment, {\n        children: result || undefined\n    }, undefined);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function one(state, node, key) {\n    if (node.type === \"element\") {\n        return element(state, node, key);\n    }\n    if (node.type === \"mdxFlowExpression\" || node.type === \"mdxTextExpression\") {\n        return mdxExpression(state, node);\n    }\n    if (node.type === \"mdxJsxFlowElement\" || node.type === \"mdxJsxTextElement\") {\n        return mdxJsxElement(state, node, key);\n    }\n    if (node.type === \"mdxjsEsm\") {\n        return mdxEsm(state, node);\n    }\n    if (node.type === \"root\") {\n        return root(state, node, key);\n    }\n    if (node.type === \"text\") {\n        return text(state, node);\n    }\n}\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function element(state, node, key) {\n    const parentSchema = state.schema;\n    let schema = parentSchema;\n    if (node.tagName.toLowerCase() === \"svg\" && parentSchema.space === \"html\") {\n        schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg;\n        state.schema = schema;\n    }\n    state.ancestors.push(node);\n    const type = findComponentFromName(state, node.tagName, false);\n    const props = createElementProps(state, node);\n    let children = createChildren(state, node);\n    if (tableElements.has(node.tagName)) {\n        children = children.filter(function(child) {\n            return typeof child === \"string\" ? !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child) : true;\n        });\n    }\n    addNode(state, props, type, node);\n    addChildren(props, children);\n    // Restore.\n    state.ancestors.pop();\n    state.schema = parentSchema;\n    return state.create(node, type, props, key);\n}\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function mdxExpression(state, node) {\n    if (node.data && node.data.estree && state.evaluater) {\n        const program = node.data.estree;\n        const expression = program.body[0];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === \"ExpressionStatement\");\n        // Assume result is a child.\n        return /** @type {Child | undefined} */ state.evaluater.evaluateExpression(expression.expression);\n    }\n    crashEstree(state, node.position);\n}\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsmHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function mdxEsm(state, node) {\n    if (node.data && node.data.estree && state.evaluater) {\n        // Assume result is a child.\n        return /** @type {Child | undefined} */ state.evaluater.evaluateProgram(node.data.estree);\n    }\n    crashEstree(state, node.position);\n}\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function mdxJsxElement(state, node, key) {\n    const parentSchema = state.schema;\n    let schema = parentSchema;\n    if (node.name === \"svg\" && parentSchema.space === \"html\") {\n        schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg;\n        state.schema = schema;\n    }\n    state.ancestors.push(node);\n    const type = node.name === null ? state.Fragment : findComponentFromName(state, node.name, true);\n    const props = createJsxElementProps(state, node);\n    const children = createChildren(state, node);\n    addNode(state, props, type, node);\n    addChildren(props, children);\n    // Restore.\n    state.ancestors.pop();\n    state.schema = parentSchema;\n    return state.create(node, type, props, key);\n}\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function root(state, node, key) {\n    /** @type {Props} */ const props = {};\n    addChildren(props, createChildren(state, node));\n    return state.create(node, state.Fragment, props, key);\n}\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function text(_, node) {\n    return node.value;\n}\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */ function addNode(state, props, type, node) {\n    // If this is swapped out for a component:\n    if (typeof type !== \"string\" && type !== state.Fragment && state.passNode) {\n        props.node = node;\n    }\n}\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */ function addChildren(props, children) {\n    if (children.length > 0) {\n        const value = children.length > 1 ? children : children[0];\n        if (value) {\n            props.children = value;\n        }\n    }\n}\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */ function productionCreate(_, jsx, jsxs) {\n    return create;\n    /** @type {Create} */ function create(_, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const fn = isStaticChildren ? jsxs : jsx;\n        return key ? fn(type, props, key) : fn(type, props);\n    }\n}\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */ function developmentCreate(filePath, jsxDEV) {\n    return create;\n    /** @type {Create} */ function create(node, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const point = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_4__.pointStart)(node);\n        return jsxDEV(type, props, key, isStaticChildren, {\n            columnNumber: point ? point.column - 1 : undefined,\n            fileName: filePath,\n            lineNumber: point ? point.line : undefined\n        }, undefined);\n    }\n}\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */ function createElementProps(state, node) {\n    /** @type {Props} */ const props = {};\n    /** @type {string | undefined} */ let alignValue;\n    /** @type {string} */ let prop;\n    for(prop in node.properties){\n        if (prop !== \"children\" && own.call(node.properties, prop)) {\n            const result = createProperty(state, prop, node.properties[prop]);\n            if (result) {\n                const [key, value] = result;\n                if (state.tableCellAlignToStyle && key === \"align\" && typeof value === \"string\" && tableCellElement.has(node.tagName)) {\n                    alignValue = value;\n                } else {\n                    props[key] = value;\n                }\n            }\n        }\n    }\n    if (alignValue) {\n        // Assume style is an object.\n        const style = /** @type {Style} */ props.style || (props.style = {});\n        style[state.stylePropertyNameCase === \"css\" ? \"text-align\" : \"textAlign\"] = alignValue;\n    }\n    return props;\n}\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */ function createJsxElementProps(state, node) {\n    /** @type {Props} */ const props = {};\n    for (const attribute of node.attributes){\n        if (attribute.type === \"mdxJsxExpressionAttribute\") {\n            if (attribute.data && attribute.data.estree && state.evaluater) {\n                const program = attribute.data.estree;\n                const expression = program.body[0];\n                (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === \"ExpressionStatement\");\n                const objectExpression = expression.expression;\n                (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(objectExpression.type === \"ObjectExpression\");\n                const property = objectExpression.properties[0];\n                (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(property.type === \"SpreadElement\");\n                Object.assign(props, state.evaluater.evaluateExpression(property.argument));\n            } else {\n                crashEstree(state, node.position);\n            }\n        } else {\n            // For JSX, the author is responsible of passing in the correct values.\n            const name = attribute.name;\n            /** @type {unknown} */ let value;\n            if (attribute.value && typeof attribute.value === \"object\") {\n                if (attribute.value.data && attribute.value.data.estree && state.evaluater) {\n                    const program = attribute.value.data.estree;\n                    const expression = program.body[0];\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === \"ExpressionStatement\");\n                    value = state.evaluater.evaluateExpression(expression.expression);\n                } else {\n                    crashEstree(state, node.position);\n                }\n            } else {\n                value = attribute.value === null ? true : attribute.value;\n            }\n            // Assume a prop.\n            props[name] = /** @type {Props[keyof Props]} */ value;\n        }\n    }\n    return props;\n}\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */ function createChildren(state, node) {\n    /** @type {Array<Child>} */ const children = [];\n    let index = -1;\n    /** @type {Map<string, number>} */ // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n    /* c8 ignore next */ const countsByName = state.passKeys ? new Map() : emptyMap;\n    while(++index < node.children.length){\n        const child = node.children[index];\n        /** @type {string | undefined} */ let key;\n        if (state.passKeys) {\n            const name = child.type === \"element\" ? child.tagName : child.type === \"mdxJsxFlowElement\" || child.type === \"mdxJsxTextElement\" ? child.name : undefined;\n            if (name) {\n                const count = countsByName.get(name) || 0;\n                key = name + \"-\" + count;\n                countsByName.set(name, count + 1);\n            }\n        }\n        const result = one(state, child, key);\n        if (result !== undefined) children.push(result);\n    }\n    return children;\n}\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */ function createProperty(state, prop, value) {\n    const info = (0,property_information__WEBPACK_IMPORTED_MODULE_5__.find)(state.schema, prop);\n    // Ignore nullish and `NaN` values.\n    if (value === null || value === undefined || typeof value === \"number\" && Number.isNaN(value)) {\n        return;\n    }\n    if (Array.isArray(value)) {\n        // Accept `array`.\n        // Most props are space-separated.\n        value = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__.stringify)(value);\n    }\n    // React only accepts `style` as object.\n    if (info.property === \"style\") {\n        let styleObject = typeof value === \"object\" ? value : parseStyle(state, String(value));\n        if (state.stylePropertyNameCase === \"css\") {\n            styleObject = transformStylesToCssCasing(styleObject);\n        }\n        return [\n            \"style\",\n            styleObject\n        ];\n    }\n    return [\n        state.elementAttributeNameCase === \"react\" && info.space ? property_information__WEBPACK_IMPORTED_MODULE_8__.hastToReact[info.property] || info.property : info.attribute,\n        value\n    ];\n}\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */ function parseStyle(state, value) {\n    try {\n        return style_to_js__WEBPACK_IMPORTED_MODULE_0__(value, {\n            reactCompat: true\n        });\n    } catch (error) {\n        if (state.ignoreInvalidStyle) {\n            return {};\n        }\n        const cause = /** @type {Error} */ error;\n        const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage(\"Cannot parse `style` attribute\", {\n            ancestors: state.ancestors,\n            cause,\n            ruleId: \"style\",\n            source: \"hast-util-to-jsx-runtime\"\n        });\n        message.file = state.filePath || undefined;\n        message.url = docs + \"#cannot-parse-style-attribute\";\n        throw message;\n    }\n}\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */ function findComponentFromName(state, name, allowExpression) {\n    /** @type {Identifier | Literal | MemberExpression} */ let result;\n    if (!allowExpression) {\n        result = {\n            type: \"Literal\",\n            value: name\n        };\n    } else if (name.includes(\".\")) {\n        const identifiers = name.split(\".\");\n        let index = -1;\n        /** @type {Identifier | Literal | MemberExpression | undefined} */ let node;\n        while(++index < identifiers.length){\n            /** @type {Identifier | Literal} */ const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(identifiers[index]) ? {\n                type: \"Identifier\",\n                name: identifiers[index]\n            } : {\n                type: \"Literal\",\n                value: identifiers[index]\n            };\n            node = node ? {\n                type: \"MemberExpression\",\n                object: node,\n                property: prop,\n                computed: Boolean(index && prop.type === \"Literal\"),\n                optional: false\n            } : prop;\n        }\n        (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(node, \"always a result\");\n        result = node;\n    } else {\n        result = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(name) && !/^[a-z]/.test(name) ? {\n            type: \"Identifier\",\n            name\n        } : {\n            type: \"Literal\",\n            value: name\n        };\n    }\n    // Only literals can be passed in `components` currently.\n    // No identifiers / member expressions.\n    if (result.type === \"Literal\") {\n        const name = /** @type {string | number} */ result.value;\n        return own.call(state.components, name) ? state.components[name] : name;\n    }\n    // Assume component.\n    if (state.evaluater) {\n        return state.evaluater.evaluateExpression(result);\n    }\n    crashEstree(state);\n}\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */ function crashEstree(state, place) {\n    const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage(\"Cannot handle MDX estrees without `createEvaluater`\", {\n        ancestors: state.ancestors,\n        place,\n        ruleId: \"mdx-estree\",\n        source: \"hast-util-to-jsx-runtime\"\n    });\n    message.file = state.filePath || undefined;\n    message.url = docs + \"#cannot-handle-mdx-estrees-without-createevaluater\";\n    throw message;\n}\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */ function transformStylesToCssCasing(domCasing) {\n    /** @type {Style} */ const cssCasing = {};\n    /** @type {string} */ let from;\n    for(from in domCasing){\n        if (own.call(domCasing, from)) {\n            cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n        }\n    }\n    return cssCasing;\n}\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */ function transformStyleToCssCasing(from) {\n    let to = from.replace(cap, toDash);\n    // Handle `ms-xxx` -> `-ms-xxx`.\n    if (to.slice(0, 3) === \"ms-\") to = \"-\" + to;\n    return to;\n}\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */ function toDash($0) {\n    return \"-\" + $0.toLowerCase();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lQDIuMy42L25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUV5RDtBQUN2QjtBQUNvQztBQUN4QjtBQUNrQjtBQUNQO0FBQ3ZCO0FBQ1c7QUFDSjtBQUUxQyxzQ0FBc0M7QUFDdEMsTUFBTWUsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFN0IsZ0NBQWdDLEdBQ2hDLE1BQU1DLFdBQVcsSUFBSUM7QUFFckIsTUFBTUMsTUFBTTtBQUVaLGtFQUFrRTtBQUNsRSw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQzNFLFFBQVE7QUFFUixzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDZEQUE2RDtBQUM3RCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCxNQUFNQyxnQkFBZ0IsSUFBSUMsSUFBSTtJQUFDO0lBQVM7SUFBUztJQUFTO0lBQVM7Q0FBSztBQUV4RSxNQUFNQyxtQkFBbUIsSUFBSUQsSUFBSTtJQUFDO0lBQU07Q0FBSztBQUU3QyxNQUFNRSxPQUFPO0FBRWI7Ozs7Ozs7Ozs7Q0FVQyxHQUVNLFNBQVNDLGFBQWFDLElBQUksRUFBRUMsT0FBTztJQUN4QyxJQUFJLENBQUNBLFdBQVdBLFFBQVFDLFFBQVEsS0FBS0MsV0FBVztRQUM5QyxNQUFNLElBQUlDLFVBQVU7SUFDdEI7SUFFQSxNQUFNQyxXQUFXSixRQUFRSSxRQUFRLElBQUlGO0lBQ3JDLG1CQUFtQixHQUNuQixJQUFJRztJQUVKLElBQUlMLFFBQVFNLFdBQVcsRUFBRTtRQUN2QixJQUFJLE9BQU9OLFFBQVFPLE1BQU0sS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUosVUFDUjtRQUVKO1FBRUFFLFNBQVNHLGtCQUFrQkosVUFBVUosUUFBUU8sTUFBTTtJQUNyRCxPQUFPO1FB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Ozs7O0NBS0MsR0FDRCxTQUFTSiwyQkFBMkJtQixTQUFTO0lBQzNDLGtCQUFrQixHQUNsQixNQUFNQyxZQUFZLENBQUM7SUFDbkIsbUJBQW1CLEdBQ25CLElBQUlDO0lBRUosSUFBS0EsUUFBUUYsVUFBVztRQUN0QixJQUFJakksSUFBSXdGLElBQUksQ0FBQ3lDLFdBQVdFLE9BQU87WUFDN0JELFNBQVMsQ0FBQ0UsMEJBQTBCRCxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0UsS0FBSztRQUM5RDtJQUNGO0lBRUEsT0FBT0Q7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0UsMEJBQTBCRCxJQUFJO0lBQ3JDLElBQUlFLEtBQUtGLEtBQUtHLE9BQU8sQ0FBQ2xJLEtBQUttSTtJQUMzQixnQ0FBZ0M7SUFDaEMsSUFBSUYsR0FBR0csS0FBSyxDQUFDLEdBQUcsT0FBTyxPQUFPSCxLQUFLLE1BQU1BO0lBQ3pDLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0UsT0FBT0UsRUFBRTtJQUNoQixPQUFPLE1BQU1BLEdBQUd2RixXQUFXO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW50ZXJ2aWV3Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1qc3gtcnVudGltZUAyLjMuNi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lL2xpYi9pbmRleC5qcz84NDhkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SWRlbnRpZmllciwgTGl0ZXJhbCwgTWVtYmVyRXhwcmVzc2lvbn0gZnJvbSAnZXN0cmVlJ1xuICogQGltcG9ydCB7SnN4LCBKc3hEZXYsIE9wdGlvbnMsIFByb3BzfSBmcm9tICdoYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUnXG4gKiBAaW1wb3J0IHtFbGVtZW50LCBOb2RlcywgUGFyZW50cywgUm9vdCwgVGV4dH0gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge01keEZsb3dFeHByZXNzaW9uSGFzdCwgTWR4VGV4dEV4cHJlc3Npb25IYXN0fSBmcm9tICdtZGFzdC11dGlsLW1keC1leHByZXNzaW9uJ1xuICogQGltcG9ydCB7TWR4SnN4Rmxvd0VsZW1lbnRIYXN0LCBNZHhKc3hUZXh0RWxlbWVudEhhc3R9IGZyb20gJ21kYXN0LXV0aWwtbWR4LWpzeCdcbiAqIEBpbXBvcnQge01keGpzRXNtSGFzdH0gZnJvbSAnbWRhc3QtdXRpbC1tZHhqcy1lc20nXG4gKiBAaW1wb3J0IHtQb3NpdGlvbn0gZnJvbSAndW5pc3QnXG4gKiBAaW1wb3J0IHtDaGlsZCwgQ3JlYXRlLCBGaWVsZCwgSnN4RWxlbWVudCwgU3RhdGUsIFN0eWxlfSBmcm9tICcuL3R5cGVzLmpzJ1xuICovXG5cbmltcG9ydCB7c3RyaW5naWZ5IGFzIGNvbW1hc30gZnJvbSAnY29tbWEtc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge25hbWUgYXMgaXNJZGVudGlmaWVyTmFtZX0gZnJvbSAnZXN0cmVlLXV0aWwtaXMtaWRlbnRpZmllci1uYW1lJ1xuaW1wb3J0IHt3aGl0ZXNwYWNlfSBmcm9tICdoYXN0LXV0aWwtd2hpdGVzcGFjZSdcbmltcG9ydCB7ZmluZCwgaGFzdFRvUmVhY3QsIGh0bWwsIHN2Z30gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG5pbXBvcnQge3N0cmluZ2lmeSBhcyBzcGFjZXN9IGZyb20gJ3NwYWNlLXNlcGFyYXRlZC10b2tlbnMnXG5pbXBvcnQgc3R5bGVUb0pzIGZyb20gJ3N0eWxlLXRvLWpzJ1xuaW1wb3J0IHtwb2ludFN0YXJ0fSBmcm9tICd1bmlzdC11dGlsLXBvc2l0aW9uJ1xuaW1wb3J0IHtWRmlsZU1lc3NhZ2V9IGZyb20gJ3ZmaWxlLW1lc3NhZ2UnXG5cbi8vIFRvIGRvOiBuZXh0IG1ham9yOiBgT2JqZWN0Lmhhc093bmAuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59ICovXG5jb25zdCBlbXB0eU1hcCA9IG5ldyBNYXAoKVxuXG5jb25zdCBjYXAgPSAvW0EtWl0vZ1xuXG4vLyBgcmVhY3QtZG9tYCB0cmlnZ2VycyBhIHdhcm5pbmcgZm9yICphbnkqIHdoaXRlIHNwYWNlIGluIHRhYmxlcy5cbi8vIFRvIGZvbGxvdyBHRk0sIGBtZGFzdC11dGlsLXRvLWhhc3RgIGluamVjdHMgbGluZSBlbmRpbmdzIGJldHdlZW4gZWxlbWVudHMuXG4vLyBPdGhlciB0b29scyBtaWdodCBkbyBzbyB0b28sIGJ1dCB0aGV5IGRvbuKAmXQgZG8gaGVyZSwgc28gd2UgcmVtb3ZlIGFsbCBvZlxuLy8gdGhhdC5cblxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzA4MT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83NTE1Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZW1hcmstcmVhY3QvaXNzdWVzLzY0Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3QvcHVsbC8yOT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0L3B1bGwvMzI+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdC9wdWxsLzQ1Pi5cbmNvbnN0IHRhYmxlRWxlbWVudHMgPSBuZXcgU2V0KFsndGFibGUnLCAndGJvZHknLCAndGhlYWQnLCAndGZvb3QnLCAndHInXSlcblxuY29uc3QgdGFibGVDZWxsRWxlbWVudCA9IG5ldyBTZXQoWyd0ZCcsICd0aCddKVxuXG5jb25zdCBkb2NzID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUnXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgaGFzdCB0cmVlIHRvIHByZWFjdCwgcmVhY3QsIHNvbGlkLCBzdmVsdGUsIHZ1ZSwgZXRjLixcbiAqIHdpdGggYW4gYXV0b21hdGljIEpTWCBydW50aW1lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge0pzeEVsZW1lbnR9XG4gKiAgIEpTWCBlbGVtZW50LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0pzeFJ1bnRpbWUodHJlZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5GcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYEZyYWdtZW50YCBpbiBvcHRpb25zJylcbiAgfVxuXG4gIGNvbnN0IGZpbGVQYXRoID0gb3B0aW9ucy5maWxlUGF0aCB8fCB1bmRlZmluZWRcbiAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG4gIGxldCBjcmVhdGVcblxuICBpZiAob3B0aW9ucy5kZXZlbG9wbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3hERVYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBganN4REVWYCBpbiBvcHRpb25zIHdoZW4gYGRldmVsb3BtZW50OiB0cnVlYCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBjcmVhdGUgPSBkZXZlbG9wbWVudENyZWF0ZShmaWxlUGF0aCwgb3B0aW9ucy5qc3hERVYpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGpzeGAgaW4gcHJvZHVjdGlvbiBvcHRpb25zJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGpzeHNgIGluIHByb2R1Y3Rpb24gb3B0aW9ucycpXG4gICAgfVxuXG4gICAgY3JlYXRlID0gcHJvZHVjdGlvbkNyZWF0ZShmaWxlUGF0aCwgb3B0aW9ucy5qc3gsIG9wdGlvbnMuanN4cylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIEZyYWdtZW50OiBvcHRpb25zLkZyYWdtZW50LFxuICAgIGFuY2VzdG9yczogW10sXG4gICAgY29tcG9uZW50czogb3B0aW9ucy5jb21wb25lbnRzIHx8IHt9LFxuICAgIGNyZWF0ZSxcbiAgICBlbGVtZW50QXR0cmlidXRlTmFtZUNhc2U6IG9wdGlvbnMuZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlIHx8ICdyZWFjdCcsXG4gICAgZXZhbHVhdGVyOiBvcHRpb25zLmNyZWF0ZUV2YWx1YXRlciA/IG9wdGlvbnMuY3JlYXRlRXZhbHVhdGVyKCkgOiB1bmRlZmluZWQsXG4gICAgZmlsZVBhdGgsXG4gICAgaWdub3JlSW52YWxpZFN0eWxlOiBvcHRpb25zLmlnbm9yZUludmFsaWRTdHlsZSB8fCBmYWxzZSxcbiAgICBwYXNzS2V5czogb3B0aW9ucy5wYXNzS2V5cyAhPT0gZmFsc2UsXG4gICAgcGFzc05vZGU6IG9wdGlvbnMucGFzc05vZGUgfHwgZmFsc2UsXG4gICAgc2NoZW1hOiBvcHRpb25zLnNwYWNlID09PSAnc3ZnJyA/IHN2ZyA6IGh0bWwsXG4gICAgc3R5bGVQcm9wZXJ0eU5hbWVDYXNlOiBvcHRpb25zLnN0eWxlUHJvcGVydHlOYW1lQ2FzZSB8fCAnZG9tJyxcbiAgICB0YWJsZUNlbGxBbGlnblRvU3R5bGU6IG9wdGlvbnMudGFibGVDZWxsQWxpZ25Ub1N0eWxlICE9PSBmYWxzZVxuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gb25lKHN0YXRlLCB0cmVlLCB1bmRlZmluZWQpXG5cbiAgLy8gSlNYIGVsZW1lbnQuXG4gIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBUZXh0IG5vZGUgb3Igc29tZXRoaW5nIHRoYXQgdHVybmVkIGludG8gbm90aGluZy5cbiAgcmV0dXJuIHN0YXRlLmNyZWF0ZShcbiAgICB0cmVlLFxuICAgIHN0YXRlLkZyYWdtZW50LFxuICAgIHtjaGlsZHJlbjogcmVzdWx0IHx8IHVuZGVmaW5lZH0sXG4gICAgdW5kZWZpbmVkXG4gIClcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gb25lKHN0YXRlLCBub2RlLCBrZXkpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQoc3RhdGUsIG5vZGUsIGtleSlcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdtZHhGbG93RXhwcmVzc2lvbicgfHwgbm9kZS50eXBlID09PSAnbWR4VGV4dEV4cHJlc3Npb24nKSB7XG4gICAgcmV0dXJuIG1keEV4cHJlc3Npb24oc3RhdGUsIG5vZGUpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAnbWR4SnN4Rmxvd0VsZW1lbnQnIHx8IG5vZGUudHlwZSA9PT0gJ21keEpzeFRleHRFbGVtZW50Jykge1xuICAgIHJldHVybiBtZHhKc3hFbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAnbWR4anNFc20nKSB7XG4gICAgcmV0dXJuIG1keEVzbShzdGF0ZSwgbm9kZSlcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdyb290Jykge1xuICAgIHJldHVybiByb290KHN0YXRlLCBub2RlLCBrZXkpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gdGV4dChzdGF0ZSwgbm9kZSlcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBlbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpIHtcbiAgY29uc3QgcGFyZW50U2NoZW1hID0gc3RhdGUuc2NoZW1hXG4gIGxldCBzY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICBpZiAobm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIHBhcmVudFNjaGVtYS5zcGFjZSA9PT0gJ2h0bWwnKSB7XG4gICAgc2NoZW1hID0gc3ZnXG4gICAgc3RhdGUuc2NoZW1hID0gc2NoZW1hXG4gIH1cblxuICBzdGF0ZS5hbmNlc3RvcnMucHVzaChub2RlKVxuXG4gIGNvbnN0IHR5cGUgPSBmaW5kQ29tcG9uZW50RnJvbU5hbWUoc3RhdGUsIG5vZGUudGFnTmFtZSwgZmFsc2UpXG4gIGNvbnN0IHByb3BzID0gY3JlYXRlRWxlbWVudFByb3BzKHN0YXRlLCBub2RlKVxuICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbihzdGF0ZSwgbm9kZSlcblxuICBpZiAodGFibGVFbGVtZW50cy5oYXMobm9kZS50YWdOYW1lKSkge1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgPyAhd2hpdGVzcGFjZShjaGlsZCkgOiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKVxuICBhZGRDaGlsZHJlbihwcm9wcywgY2hpbGRyZW4pXG5cbiAgLy8gUmVzdG9yZS5cbiAgc3RhdGUuYW5jZXN0b3JzLnBvcCgpXG4gIHN0YXRlLnNjaGVtYSA9IHBhcmVudFNjaGVtYVxuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUobm9kZSwgdHlwZSwgcHJvcHMsIGtleSlcbn1cblxuLyoqXG4gKiBIYW5kbGUgTURYIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtNZHhGbG93RXhwcmVzc2lvbkhhc3QgfCBNZHhUZXh0RXhwcmVzc2lvbkhhc3R9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG1keEV4cHJlc3Npb24oc3RhdGUsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGF0YSAmJiBub2RlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikge1xuICAgIGNvbnN0IHByb2dyYW0gPSBub2RlLmRhdGEuZXN0cmVlXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHByb2dyYW0uYm9keVswXVxuICAgIGFzc2VydChleHByZXNzaW9uLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JylcblxuICAgIC8vIEFzc3VtZSByZXN1bHQgaXMgYSBjaGlsZC5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtDaGlsZCB8IHVuZGVmaW5lZH0gKi8gKFxuICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLmV4cHJlc3Npb24pXG4gICAgKVxuICB9XG5cbiAgY3Jhc2hFc3RyZWUoc3RhdGUsIG5vZGUucG9zaXRpb24pXG59XG5cbi8qKlxuICogSGFuZGxlIE1EWCBFU00uXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtNZHhqc0VzbUhhc3R9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG1keEVzbShzdGF0ZSwgbm9kZSkge1xuICBpZiAobm9kZS5kYXRhICYmIG5vZGUuZGF0YS5lc3RyZWUgJiYgc3RhdGUuZXZhbHVhdGVyKSB7XG4gICAgLy8gQXNzdW1lIHJlc3VsdCBpcyBhIGNoaWxkLlxuICAgIHJldHVybiAvKiogQHR5cGUge0NoaWxkIHwgdW5kZWZpbmVkfSAqLyAoXG4gICAgICBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVQcm9ncmFtKG5vZGUuZGF0YS5lc3RyZWUpXG4gICAgKVxuICB9XG5cbiAgY3Jhc2hFc3RyZWUoc3RhdGUsIG5vZGUucG9zaXRpb24pXG59XG5cbi8qKlxuICogSGFuZGxlIE1EWCBKU1guXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtNZHhKc3hGbG93RWxlbWVudEhhc3QgfCBNZHhKc3hUZXh0RWxlbWVudEhhc3R9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gbWR4SnN4RWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYVxuICBsZXQgc2NoZW1hID0gcGFyZW50U2NoZW1hXG5cbiAgaWYgKG5vZGUubmFtZSA9PT0gJ3N2ZycgJiYgcGFyZW50U2NoZW1hLnNwYWNlID09PSAnaHRtbCcpIHtcbiAgICBzY2hlbWEgPSBzdmdcbiAgICBzdGF0ZS5zY2hlbWEgPSBzY2hlbWFcbiAgfVxuXG4gIHN0YXRlLmFuY2VzdG9ycy5wdXNoKG5vZGUpXG5cbiAgY29uc3QgdHlwZSA9XG4gICAgbm9kZS5uYW1lID09PSBudWxsXG4gICAgICA/IHN0YXRlLkZyYWdtZW50XG4gICAgICA6IGZpbmRDb21wb25lbnRGcm9tTmFtZShzdGF0ZSwgbm9kZS5uYW1lLCB0cnVlKVxuICBjb25zdCBwcm9wcyA9IGNyZWF0ZUpzeEVsZW1lbnRQcm9wcyhzdGF0ZSwgbm9kZSlcbiAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbihzdGF0ZSwgbm9kZSlcblxuICBhZGROb2RlKHN0YXRlLCBwcm9wcywgdHlwZSwgbm9kZSlcbiAgYWRkQ2hpbGRyZW4ocHJvcHMsIGNoaWxkcmVuKVxuXG4gIC8vIFJlc3RvcmUuXG4gIHN0YXRlLmFuY2VzdG9ycy5wb3AoKVxuICBzdGF0ZS5zY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICByZXR1cm4gc3RhdGUuY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpXG59XG5cbi8qKlxuICogSGFuZGxlIHJvb3QuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtSb290fSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgS2V5LlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIHJvb3Qoc3RhdGUsIG5vZGUsIGtleSkge1xuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBjb25zdCBwcm9wcyA9IHt9XG5cbiAgYWRkQ2hpbGRyZW4ocHJvcHMsIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSlcblxuICByZXR1cm4gc3RhdGUuY3JlYXRlKG5vZGUsIHN0YXRlLkZyYWdtZW50LCBwcm9wcywga2V5KVxufVxuXG4vKipcbiAqIEhhbmRsZSB0ZXh0LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IF9cbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtUZXh0fSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiB0ZXh0KF8sIG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudmFsdWVcbn1cblxuLyoqXG4gKiBBZGQgYG5vZGVgIHRvIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7UHJvcHN9IHByb3BzXG4gKiAgIFByb3BzLlxuICogQHBhcmFtIHt1bmtub3dufSB0eXBlXG4gKiAgIFR5cGUuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBNZHhKc3hGbG93RWxlbWVudEhhc3QgfCBNZHhKc3hUZXh0RWxlbWVudEhhc3R9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKSB7XG4gIC8vIElmIHRoaXMgaXMgc3dhcHBlZCBvdXQgZm9yIGEgY29tcG9uZW50OlxuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09IHN0YXRlLkZyYWdtZW50ICYmIHN0YXRlLnBhc3NOb2RlKSB7XG4gICAgcHJvcHMubm9kZSA9IG5vZGVcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBjaGlsZHJlbiB0byBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1Byb3BzfSBwcm9wc1xuICogICBQcm9wcy5cbiAqIEBwYXJhbSB7QXJyYXk8Q2hpbGQ+fSBjaGlsZHJlblxuICogICBDaGlsZHJlbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHByb3BzLCBjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHZhbHVlID0gY2hpbGRyZW4ubGVuZ3RoID4gMSA/IGNoaWxkcmVuIDogY2hpbGRyZW5bMF1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2YWx1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBfXG4gKiAgIFBhdGggdG8gZmlsZS5cbiAqIEBwYXJhbSB7SnN4fSBqc3hcbiAqICAgRHluYW1pYy5cbiAqIEBwYXJhbSB7SnN4fSBqc3hzXG4gKiAgIFN0YXRpYy5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIHByb2R1Y3Rpb24gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcHJvZHVjdGlvbkNyZWF0ZShfLCBqc3gsIGpzeHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKF8sIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBmbiA9IGlzU3RhdGljQ2hpbGRyZW4gPyBqc3hzIDoganN4XG4gICAgcmV0dXJuIGtleSA/IGZuKHR5cGUsIHByb3BzLCBrZXkpIDogZm4odHlwZSwgcHJvcHMpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gZmlsZVBhdGhcbiAqICAgUGF0aCB0byBmaWxlLlxuICogQHBhcmFtIHtKc3hEZXZ9IGpzeERFVlxuICogICBEZXZlbG9wbWVudC5cbiAqIEByZXR1cm5zIHtDcmVhdGV9XG4gKiAgIENyZWF0ZSBhIGRldmVsb3BtZW50IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGRldmVsb3BtZW50Q3JlYXRlKGZpbGVQYXRoLCBqc3hERVYpIHtcbiAgcmV0dXJuIGNyZWF0ZVxuICAvKiogQHR5cGUge0NyZWF0ZX0gKi9cbiAgZnVuY3Rpb24gY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpIHtcbiAgICAvLyBPbmx5IGFuIGFycmF5IHdoZW4gdGhlcmUgYXJlIDIgb3IgbW9yZSBjaGlsZHJlbi5cbiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbilcbiAgICBjb25zdCBwb2ludCA9IHBvaW50U3RhcnQobm9kZSlcbiAgICByZXR1cm4ganN4REVWKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAga2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHtcbiAgICAgICAgY29sdW1uTnVtYmVyOiBwb2ludCA/IHBvaW50LmNvbHVtbiAtIDEgOiB1bmRlZmluZWQsXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlUGF0aCxcbiAgICAgICAgbGluZU51bWJlcjogcG9pbnQgPyBwb2ludC5saW5lIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHByb3BzIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb3BzfVxuICogICBQcm9wcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gIGxldCBhbGlnblZhbHVlXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgcHJvcFxuXG4gIGZvciAocHJvcCBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ2NoaWxkcmVuJyAmJiBvd24uY2FsbChub2RlLnByb3BlcnRpZXMsIHByb3ApKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCwgbm9kZS5wcm9wZXJ0aWVzW3Byb3BdKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHJlc3VsdFxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdGF0ZS50YWJsZUNlbGxBbGlnblRvU3R5bGUgJiZcbiAgICAgICAgICBrZXkgPT09ICdhbGlnbicgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgdGFibGVDZWxsRWxlbWVudC5oYXMobm9kZS50YWdOYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICBhbGlnblZhbHVlID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1trZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGlnblZhbHVlKSB7XG4gICAgLy8gQXNzdW1lIHN0eWxlIGlzIGFuIG9iamVjdC5cbiAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChwcm9wcy5zdHlsZSB8fCAocHJvcHMuc3R5bGUgPSB7fSkpXG4gICAgc3R5bGVbc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJyA/ICd0ZXh0LWFsaWduJyA6ICd0ZXh0QWxpZ24nXSA9XG4gICAgICBhbGlnblZhbHVlXG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuLyoqXG4gKiBDcmVhdGUgcHJvcHMgZnJvbSBhIEpTWCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnRIYXN0IHwgTWR4SnN4VGV4dEVsZW1lbnRIYXN0fSBub2RlXG4gKiAgIEN1cnJlbnQgSlNYIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7UHJvcHN9XG4gKiAgIFByb3BzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVKc3hFbGVtZW50UHJvcHMoc3RhdGUsIG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgY29uc3QgcHJvcHMgPSB7fVxuXG4gIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIG5vZGUuYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ21keEpzeEV4cHJlc3Npb25BdHRyaWJ1dGUnKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLmRhdGEgJiYgYXR0cmlidXRlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikge1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gYXR0cmlidXRlLmRhdGEuZXN0cmVlXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwcm9ncmFtLmJvZHlbMF1cbiAgICAgICAgYXNzZXJ0KGV4cHJlc3Npb24udHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKVxuICAgICAgICBjb25zdCBvYmplY3RFeHByZXNzaW9uID0gZXhwcmVzc2lvbi5leHByZXNzaW9uXG4gICAgICAgIGFzc2VydChvYmplY3RFeHByZXNzaW9uLnR5cGUgPT09ICdPYmplY3RFeHByZXNzaW9uJylcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBvYmplY3RFeHByZXNzaW9uLnByb3BlcnRpZXNbMF1cbiAgICAgICAgYXNzZXJ0KHByb3BlcnR5LnR5cGUgPT09ICdTcHJlYWRFbGVtZW50JylcblxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHN0YXRlLmV2YWx1YXRlci5ldmFsdWF0ZUV4cHJlc3Npb24ocHJvcGVydHkuYXJndW1lbnQpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgSlNYLCB0aGUgYXV0aG9yIGlzIHJlc3BvbnNpYmxlIG9mIHBhc3NpbmcgaW4gdGhlIGNvcnJlY3QgdmFsdWVzLlxuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICAvKiogQHR5cGUge3Vua25vd259ICovXG4gICAgICBsZXQgdmFsdWVcblxuICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSAmJiB0eXBlb2YgYXR0cmlidXRlLnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmRhdGEgJiZcbiAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUuZGF0YS5lc3RyZWUgJiZcbiAgICAgICAgICBzdGF0ZS5ldmFsdWF0ZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGF0dHJpYnV0ZS52YWx1ZS5kYXRhLmVzdHJlZVxuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwcm9ncmFtLmJvZHlbMF1cbiAgICAgICAgICBhc3NlcnQoZXhwcmVzc2lvbi50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpXG4gICAgICAgICAgdmFsdWUgPSBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24uZXhwcmVzc2lvbilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUgPT09IG51bGwgPyB0cnVlIDogYXR0cmlidXRlLnZhbHVlXG4gICAgICB9XG5cbiAgICAgIC8vIEFzc3VtZSBhIHByb3AuXG4gICAgICBwcm9wc1tuYW1lXSA9IC8qKiBAdHlwZSB7UHJvcHNba2V5b2YgUHJvcHNdfSAqLyAodmFsdWUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbi8qKlxuICogQ3JlYXRlIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7UGFyZW50c30gbm9kZVxuICogICBDdXJyZW50IGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXk8Q2hpbGQ+fVxuICogICBDaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxDaGlsZD59ICovXG4gIGNvbnN0IGNoaWxkcmVuID0gW11cbiAgbGV0IGluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuICAvLyBOb3RlOiB0ZXN0IHRoaXMgd2hlbiBTb2xpZCBkb2VzbuKAmXQgd2FudCB0byBtZXJnZSBteSB1cGNvbWluZyBQUi5cbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgY29uc3QgY291bnRzQnlOYW1lID0gc3RhdGUucGFzc0tleXMgPyBuZXcgTWFwKCkgOiBlbXB0eU1hcFxuXG4gIHdoaWxlICgrK2luZGV4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baW5kZXhdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGtleVxuXG4gICAgaWYgKHN0YXRlLnBhc3NLZXlzKSB7XG4gICAgICBjb25zdCBuYW1lID1cbiAgICAgICAgY2hpbGQudHlwZSA9PT0gJ2VsZW1lbnQnXG4gICAgICAgICAgPyBjaGlsZC50YWdOYW1lXG4gICAgICAgICAgOiBjaGlsZC50eXBlID09PSAnbWR4SnN4Rmxvd0VsZW1lbnQnIHx8XG4gICAgICAgICAgICAgIGNoaWxkLnR5cGUgPT09ICdtZHhKc3hUZXh0RWxlbWVudCdcbiAgICAgICAgICAgID8gY2hpbGQubmFtZVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudHNCeU5hbWUuZ2V0KG5hbWUpIHx8IDBcbiAgICAgICAga2V5ID0gbmFtZSArICctJyArIGNvdW50XG4gICAgICAgIGNvdW50c0J5TmFtZS5zZXQobmFtZSwgY291bnQgKyAxKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG9uZShzdGF0ZSwgY2hpbGQsIGtleSlcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIGNoaWxkcmVuLnB1c2gocmVzdWx0KVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8qKlxuICogSGFuZGxlIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqICAgS2V5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHZhbHVlXG4gKiAgIGhhc3QgcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJucyB7RmllbGQgfCB1bmRlZmluZWR9XG4gKiAgIEZpZWxkIGZvciBydW50aW1lLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHkoc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IGluZm8gPSBmaW5kKHN0YXRlLnNjaGVtYSwgcHJvcClcblxuICAvLyBJZ25vcmUgbnVsbGlzaCBhbmQgYE5hTmAgdmFsdWVzLlxuICBpZiAoXG4gICAgdmFsdWUgPT09IG51bGwgfHxcbiAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBBY2NlcHQgYGFycmF5YC5cbiAgICAvLyBNb3N0IHByb3BzIGFyZSBzcGFjZS1zZXBhcmF0ZWQuXG4gICAgdmFsdWUgPSBpbmZvLmNvbW1hU2VwYXJhdGVkID8gY29tbWFzKHZhbHVlKSA6IHNwYWNlcyh2YWx1ZSlcbiAgfVxuXG4gIC8vIFJlYWN0IG9ubHkgYWNjZXB0cyBgc3R5bGVgIGFzIG9iamVjdC5cbiAgaWYgKGluZm8ucHJvcGVydHkgPT09ICdzdHlsZScpIHtcbiAgICBsZXQgc3R5bGVPYmplY3QgPVxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlIDogcGFyc2VTdHlsZShzdGF0ZSwgU3RyaW5nKHZhbHVlKSlcblxuICAgIGlmIChzdGF0ZS5zdHlsZVByb3BlcnR5TmFtZUNhc2UgPT09ICdjc3MnKSB7XG4gICAgICBzdHlsZU9iamVjdCA9IHRyYW5zZm9ybVN0eWxlc1RvQ3NzQ2FzaW5nKHN0eWxlT2JqZWN0KVxuICAgIH1cblxuICAgIHJldHVybiBbJ3N0eWxlJywgc3R5bGVPYmplY3RdXG4gIH1cblxuICByZXR1cm4gW1xuICAgIHN0YXRlLmVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSA9PT0gJ3JlYWN0JyAmJiBpbmZvLnNwYWNlXG4gICAgICA/IGhhc3RUb1JlYWN0W2luZm8ucHJvcGVydHldIHx8IGluZm8ucHJvcGVydHlcbiAgICAgIDogaW5mby5hdHRyaWJ1dGUsXG4gICAgdmFsdWVcbiAgXVxufVxuXG4vKipcbiAqIFBhcnNlIGEgQ1NTIGRlY2xhcmF0aW9uIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgQ1NTIGRlY2xhcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtTdHlsZX1cbiAqICAgUHJvcGVydGllcy5cbiAqIEB0aHJvd3NcbiAqICAgVGhyb3dzIGBWRmlsZU1lc3NhZ2VgIHdoZW4gQ1NTIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3RhdGUsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHN0eWxlVG9Kcyh2YWx1ZSwge3JlYWN0Q29tcGF0OiB0cnVlfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoc3RhdGUuaWdub3JlSW52YWxpZFN0eWxlKSB7XG4gICAgICByZXR1cm4ge31cbiAgICB9XG5cbiAgICBjb25zdCBjYXVzZSA9IC8qKiBAdHlwZSB7RXJyb3J9ICovIChlcnJvcilcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IFZGaWxlTWVzc2FnZSgnQ2Fubm90IHBhcnNlIGBzdHlsZWAgYXR0cmlidXRlJywge1xuICAgICAgYW5jZXN0b3JzOiBzdGF0ZS5hbmNlc3RvcnMsXG4gICAgICBjYXVzZSxcbiAgICAgIHJ1bGVJZDogJ3N0eWxlJyxcbiAgICAgIHNvdXJjZTogJ2hhc3QtdXRpbC10by1qc3gtcnVudGltZSdcbiAgICB9KVxuICAgIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHVuZGVmaW5lZFxuICAgIG1lc3NhZ2UudXJsID0gZG9jcyArICcjY2Fubm90LXBhcnNlLXN0eWxlLWF0dHJpYnV0ZSdcblxuICAgIHRocm93IG1lc3NhZ2VcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIEpTWCBuYW1lIGZyb20gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgVG8gZG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICBOYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd0V4cHJlc3Npb25cbiAqICAgQWxsb3cgbWVtYmVyIGV4cHJlc3Npb25zIGFuZCBpZGVudGlmaWVycy5cbiAqIEByZXR1cm5zIHt1bmtub3dufVxuICogICBUbyBkby5cbiAqL1xuZnVuY3Rpb24gZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBuYW1lLCBhbGxvd0V4cHJlc3Npb24pIHtcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gIGxldCByZXN1bHRcblxuICBpZiAoIWFsbG93RXhwcmVzc2lvbikge1xuICAgIHJlc3VsdCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBuYW1lfVxuICB9IGVsc2UgaWYgKG5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gbmFtZS5zcGxpdCgnLicpXG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgbm9kZVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBpZGVudGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWx9ICovXG4gICAgICBjb25zdCBwcm9wID0gaXNJZGVudGlmaWVyTmFtZShpZGVudGlmaWVyc1tpbmRleF0pXG4gICAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogaWRlbnRpZmllcnNbaW5kZXhdfVxuICAgICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICBub2RlID0gbm9kZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIG9iamVjdDogbm9kZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IEJvb2xlYW4oaW5kZXggJiYgcHJvcC50eXBlID09PSAnTGl0ZXJhbCcpLFxuICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICA6IHByb3BcbiAgICB9XG5cbiAgICBhc3NlcnQobm9kZSwgJ2Fsd2F5cyBhIHJlc3VsdCcpXG4gICAgcmVzdWx0ID0gbm9kZVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9XG4gICAgICBpc0lkZW50aWZpZXJOYW1lKG5hbWUpICYmICEvXlthLXpdLy50ZXN0KG5hbWUpXG4gICAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZX1cbiAgICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbmFtZX1cbiAgfVxuXG4gIC8vIE9ubHkgbGl0ZXJhbHMgY2FuIGJlIHBhc3NlZCBpbiBgY29tcG9uZW50c2AgY3VycmVudGx5LlxuICAvLyBObyBpZGVudGlmaWVycyAvIG1lbWJlciBleHByZXNzaW9ucy5cbiAgaWYgKHJlc3VsdC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICBjb25zdCBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmcgfCBudW1iZXJ9ICovIChyZXN1bHQudmFsdWUpXG4gICAgcmV0dXJuIG93bi5jYWxsKHN0YXRlLmNvbXBvbmVudHMsIG5hbWUpID8gc3RhdGUuY29tcG9uZW50c1tuYW1lXSA6IG5hbWVcbiAgfVxuXG4gIC8vIEFzc3VtZSBjb21wb25lbnQuXG4gIGlmIChzdGF0ZS5ldmFsdWF0ZXIpIHtcbiAgICByZXR1cm4gc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihyZXN1bHQpXG4gIH1cblxuICBjcmFzaEVzdHJlZShzdGF0ZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtQb3NpdGlvbiB8IHVuZGVmaW5lZH0gW3BsYWNlXVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5mdW5jdGlvbiBjcmFzaEVzdHJlZShzdGF0ZSwgcGxhY2UpIHtcbiAgY29uc3QgbWVzc2FnZSA9IG5ldyBWRmlsZU1lc3NhZ2UoXG4gICAgJ0Nhbm5vdCBoYW5kbGUgTURYIGVzdHJlZXMgd2l0aG91dCBgY3JlYXRlRXZhbHVhdGVyYCcsXG4gICAge1xuICAgICAgYW5jZXN0b3JzOiBzdGF0ZS5hbmNlc3RvcnMsXG4gICAgICBwbGFjZSxcbiAgICAgIHJ1bGVJZDogJ21keC1lc3RyZWUnLFxuICAgICAgc291cmNlOiAnaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lJ1xuICAgIH1cbiAgKVxuICBtZXNzYWdlLmZpbGUgPSBzdGF0ZS5maWxlUGF0aCB8fCB1bmRlZmluZWRcbiAgbWVzc2FnZS51cmwgPSBkb2NzICsgJyNjYW5ub3QtaGFuZGxlLW1keC1lc3RyZWVzLXdpdGhvdXQtY3JlYXRlZXZhbHVhdGVyJ1xuXG4gIHRocm93IG1lc3NhZ2Vcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBET00gY2FzaW5nIHN0eWxlIG9iamVjdCB0byBhIENTUyBjYXNpbmcgc3R5bGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3R5bGV9IGRvbUNhc2luZ1xuICogQHJldHVybnMge1N0eWxlfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhkb21DYXNpbmcpIHtcbiAgLyoqIEB0eXBlIHtTdHlsZX0gKi9cbiAgY29uc3QgY3NzQ2FzaW5nID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBmcm9tXG5cbiAgZm9yIChmcm9tIGluIGRvbUNhc2luZykge1xuICAgIGlmIChvd24uY2FsbChkb21DYXNpbmcsIGZyb20pKSB7XG4gICAgICBjc3NDYXNpbmdbdHJhbnNmb3JtU3R5bGVUb0Nzc0Nhc2luZyhmcm9tKV0gPSBkb21DYXNpbmdbZnJvbV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3NzQ2FzaW5nXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgRE9NIGNhc2luZyBzdHlsZSBmaWVsZCB0byBhIENTUyBjYXNpbmcgc3R5bGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSkge1xuICBsZXQgdG8gPSBmcm9tLnJlcGxhY2UoY2FwLCB0b0Rhc2gpXG4gIC8vIEhhbmRsZSBgbXMteHh4YCAtPiBgLW1zLXh4eGAuXG4gIGlmICh0by5zbGljZSgwLCAzKSA9PT0gJ21zLScpIHRvID0gJy0nICsgdG9cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWFrZSBgJDBgIGRhc2ggY2FzZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiAgIENhcGl0YWxpemVkIEFTQ0lJIGxldGVyLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgRGFzaCBhbmQgbG93ZXIgbGV0dGVyLlxuICovXG5mdW5jdGlvbiB0b0Rhc2goJDApIHtcbiAgcmV0dXJuICctJyArICQwLnRvTG93ZXJDYXNlKClcbn1cbiJdLCJuYW1lcyI6WyJzdHJpbmdpZnkiLCJjb21tYXMiLCJvayIsImFzc2VydCIsIm5hbWUiLCJpc0lkZW50aWZpZXJOYW1lIiwid2hpdGVzcGFjZSIsImZpbmQiLCJoYXN0VG9SZWFjdCIsImh0bWwiLCJzdmciLCJzcGFjZXMiLCJzdHlsZVRvSnMiLCJwb2ludFN0YXJ0IiwiVkZpbGVNZXNzYWdlIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJlbXB0eU1hcCIsIk1hcCIsImNhcCIsInRhYmxlRWxlbWVudHMiLCJTZXQiLCJ0YWJsZUNlbGxFbGVtZW50IiwiZG9jcyIsInRvSnN4UnVudGltZSIsInRyZWUiLCJvcHRpb25zIiwiRnJhZ21lbnQiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJmaWxlUGF0aCIsImNyZWF0ZSIsImRldmVsb3BtZW50IiwianN4REVWIiwiZGV2ZWxvcG1lbnRDcmVhdGUiLCJqc3giLCJqc3hzIiwicHJvZHVjdGlvbkNyZWF0ZSIsInN0YXRlIiwiYW5jZXN0b3JzIiwiY29tcG9uZW50cyIsImVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSIsImV2YWx1YXRlciIsImNyZWF0ZUV2YWx1YXRlciIsImlnbm9yZUludmFsaWRTdHlsZSIsInBhc3NLZXlzIiwicGFzc05vZGUiLCJzY2hlbWEiLCJzcGFjZSIsInN0eWxlUHJvcGVydHlOYW1lQ2FzZSIsInRhYmxlQ2VsbEFsaWduVG9TdHlsZSIsInJlc3VsdCIsIm9uZSIsImNoaWxkcmVuIiwibm9kZSIsImtleSIsInR5cGUiLCJlbGVtZW50IiwibWR4RXhwcmVzc2lvbiIsIm1keEpzeEVsZW1lbnQiLCJtZHhFc20iLCJyb290IiwidGV4dCIsInBhcmVudFNjaGVtYSIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJmaW5kQ29tcG9uZW50RnJvbU5hbWUiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnRQcm9wcyIsImNyZWF0ZUNoaWxkcmVuIiwiaGFzIiwiZmlsdGVyIiwiY2hpbGQiLCJhZGROb2RlIiwiYWRkQ2hpbGRyZW4iLCJwb3AiLCJkYXRhIiwiZXN0cmVlIiwicHJvZ3JhbSIsImV4cHJlc3Npb24iLCJib2R5IiwiZXZhbHVhdGVFeHByZXNzaW9uIiwiY3Jhc2hFc3RyZWUiLCJwb3NpdGlvbiIsImV2YWx1YXRlUHJvZ3JhbSIsImNyZWF0ZUpzeEVsZW1lbnRQcm9wcyIsIl8iLCJ2YWx1ZSIsImxlbmd0aCIsImlzU3RhdGljQ2hpbGRyZW4iLCJBcnJheSIsImlzQXJyYXkiLCJmbiIsInBvaW50IiwiY29sdW1uTnVtYmVyIiwiY29sdW1uIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwibGluZSIsImFsaWduVmFsdWUiLCJwcm9wIiwicHJvcGVydGllcyIsImNhbGwiLCJjcmVhdGVQcm9wZXJ0eSIsInN0eWxlIiwiYXR0cmlidXRlIiwiYXR0cmlidXRlcyIsIm9iamVjdEV4cHJlc3Npb24iLCJwcm9wZXJ0eSIsIk9iamVjdCIsImFzc2lnbiIsImFyZ3VtZW50IiwiaW5kZXgiLCJjb3VudHNCeU5hbWUiLCJjb3VudCIsImdldCIsInNldCIsImluZm8iLCJOdW1iZXIiLCJpc05hTiIsImNvbW1hU2VwYXJhdGVkIiwic3R5bGVPYmplY3QiLCJwYXJzZVN0eWxlIiwiU3RyaW5nIiwidHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmciLCJyZWFjdENvbXBhdCIsImVycm9yIiwiY2F1c2UiLCJtZXNzYWdlIiwicnVsZUlkIiwic291cmNlIiwiZmlsZSIsInVybCIsImFsbG93RXhwcmVzc2lvbiIsImluY2x1ZGVzIiwiaWRlbnRpZmllcnMiLCJzcGxpdCIsIm9iamVjdCIsImNvbXB1dGVkIiwiQm9vbGVhbiIsIm9wdGlvbmFsIiwidGVzdCIsInBsYWNlIiwiZG9tQ2FzaW5nIiwiY3NzQ2FzaW5nIiwiZnJvbSIsInRyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmciLCJ0byIsInJlcGxhY2UiLCJ0b0Rhc2giLCJzbGljZSIsIiQwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/hast-util-to-jsx-runtime@2.3.6/node_modules/hast-util-to-jsx-runtime/lib/index.js\n");

/***/ })

};
;