"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13";
exports.ids = ["vendor-chunks/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13/node_modules/ai/react/dist/index.mjs":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13/node_modules/ai/react/dist/index.mjs ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.0_@babel+core@7.27.1_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/.pnpm/swr@2.2.0_react@18.3.1/node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/.pnpm/nanoid@3.3.6/node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            },\n            generateId\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = generateId();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else if (streamedResponse.startsWith('{\"tool_calls\":')) {\n                responseMessage[\"tool_calls\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (streamedResponse.startsWith('{\"tool_calls\":')) {\n            const parsedToolCalls = JSON.parse(streamedResponse).tool_calls;\n            responseMessage[\"tool_calls\"] = parsedToolCalls;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, onResponse, onFinish, onError, credentials, headers, body, generateId = nanoid } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n        if (isComplexMode) {\n            for await (const { type, value } of readDataStream(reader, {\n                isAborted: ()=>abortController === null\n            })){\n                switch(type){\n                    case \"text\":\n                        {\n                            result += value;\n                            setCompletion(result);\n                            break;\n                        }\n                    case \"data\":\n                        {\n                            onData == null ? void 0 : onData(value);\n                            break;\n                        }\n                }\n            }\n        } else {\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                setCompletion(result);\n                if (abortController === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction experimental_useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a, _b;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify({\n                ...body,\n                // always use user-provided threadId when available:\n                threadId: (_b = threadIdParam != null ? threadIdParam : threadId) != null ? _b : null,\n                message: input,\n                // optional request data:\n                data: requestOptions == null ? void 0 : requestOptions.data\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        try {\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : \"\",\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMi4yLjM3X3JlYWN0QDE4LjMuMV9zb2xpZC1qc0AxLjkuNl9zdmVsdGVANC4yLjE5X3Z1ZUAzLjUuMTMvbm9kZV9tb2R1bGVzL2FpL3JlYWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztxR0FFQSxvQkFBb0I7QUFDb0Q7QUFDL0M7QUFFekIseUJBQXlCO0FBQ3pCLElBQUlNLGlCQUFpQjtJQUNuQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBQ0EsSUFBSUcseUJBQXlCO0lBQzNCTixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxvQkFBbUJBLEtBQUksS0FBTSxPQUFPQSxNQUFNSSxhQUFhLEtBQUssWUFBWUosTUFBTUksYUFBYSxJQUFJLFFBQVEsQ0FBRSxXQUFVSixNQUFNSSxhQUFhLEtBQUssQ0FBRSxnQkFBZUosTUFBTUksYUFBYSxLQUFLLE9BQU9KLE1BQU1JLGFBQWEsQ0FBQ04sSUFBSSxLQUFLLFlBQVksT0FBT0UsTUFBTUksYUFBYSxDQUFDQyxTQUFTLEtBQUssVUFBVTtZQUN6VSxNQUFNLElBQUlKLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlNLGlCQUFpQjtJQUNuQlQsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLENBQUNPLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUTtZQUN6QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FB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UUFDQUk7UUFDQThCO1FBQ0FIO1FBQ0E5QztJQUNGO0FBQ0Y7QUFLRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ludGVydmlldy8uL25vZGVfbW9kdWxlcy8ucG5wbS9haUAyLjIuMzdfcmVhY3RAMTguMy4xX3NvbGlkLWpzQDEuOS42X3N2ZWx0ZUA0LjIuMTlfdnVlQDMuNS4xMy9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanM/MzdiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKCh0YykgPT4ge1xuICAgICAgdGMgPT0gbnVsbCB8fCB0eXBlb2YgdGMgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy5pZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidHlwZVwiIGluIHRjKSB8fCB0eXBlb2YgdGMudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiZnVuY3Rpb25cIiBpbiB0YykgfHwgdGMuZnVuY3Rpb24gPT0gbnVsbCB8fCB0eXBlb2YgdGMuZnVuY3Rpb24gIT09IFwib2JqZWN0XCIgfHwgIShcImFyZ3VtZW50c1wiIGluIHRjLmZ1bmN0aW9uKSB8fCB0eXBlb2YgdGMuZnVuY3Rpb24ubmFtZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdGMuZnVuY3Rpb24uYXJndW1lbnRzICE9PSBcInN0cmluZ1wiO1xuICAgIH0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcblxuLy8gc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBuYW5vaWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGlmICghY2h1bmspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKTtcbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG52YXIgQ09NUExFWF9IRUFERVIgPSBcIlgtRXhwZXJpbWVudGFsLVN0cmVhbS1EYXRhXCI7XG5cbi8vIHNoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBhbm5vdGF0aW9ucykge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkID0gbmFub2lkLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXVxuICB9O1xuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IHZvaWQgMDtcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiAoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGxcbiAgfSkpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbXCJ0ZXh0XCJdKSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwW1widGV4dFwiXS5jb250ZW50IHx8IFwiXCIpICsgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdO1xuICAgIH1cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VfYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5cyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICBcInRvb2xfY2FsbHNcIlxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICBwcmVmaXhNYXBba2V5XS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpXG4gICAgfSkpO1xuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHNoYXJlZC9jYWxsLWNoYXQtYXBpLnRzXG5hc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgbWVzc2FnZXMsXG4gIGJvZHksXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIGFwcGVuZE1lc3NhZ2UsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgLi4uYm9keVxuICAgIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiAoX2EgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGF3YWl0IHJlc3BvbnNlLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChDT01QTEVYX0hFQURFUikgPT09IFwidHJ1ZVwiO1xuICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICByZWFkZXIsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWY6IGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdm9pZCAwLFxuICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlSWRcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoZmFsc2UpO1xuICAgIGxldCBzdHJlYW1lZFJlc3BvbnNlID0gXCJcIjtcbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiXG4gICAgfTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RyZWFtZWRSZXNwb25zZSArPSBkZWNvZGUodmFsdWUpO1xuICAgICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImZ1bmN0aW9uX2NhbGxcIl0gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSkge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJ0b29sX2NhbGxzXCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImNvbnRlbnRcIl0gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICBjb25zdCBwYXJzZWRGdW5jdGlvbkNhbGwgPSBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLmZ1bmN0aW9uX2NhbGw7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJmdW5jdGlvbl9jYWxsXCJdID0gcGFyc2VkRnVuY3Rpb25DYWxsO1xuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKSB7XG4gICAgICBjb25zdCBwYXJzZWRUb29sQ2FsbHMgPSBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLnRvb2xfY2FsbHM7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ0b29sX2NhbGxzXCJdID0gcGFyc2VkVG9vbENhbGxzO1xuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG59XG5cbi8vIHNoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6IGdldFN0cmVhbWVkUmVzcG9uc2UyLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzXG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UyKCk7XG4gICAgaWYgKFwibWVzc2FnZXNcIiBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmICgobWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDAgfHwgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikgJiYgKG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25DYWxsICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fCB0b29sQ2FsbHMuc29tZSgodG9vbENhbGwpID0+IHR5cGVvZiB0b29sQ2FsbCAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0ZvbGxvd2luZ1Jlc3BvbnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiYgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAmJiB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyA9IGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czI7XG4gICAgICBjb25zdCBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2U7XG4gICAgICBpZiAoKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikgJiYgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIGlmICghKHR5cGVvZiBmdW5jdGlvbkNhbGwgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIGZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgIGlmICghKHR5cGVvZiB0b29sQ2FsbHMgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyBmdW5jdGlvbnNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyKHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbnZhciBnZXRTdHJlYW1lZFJlc3BvbnNlID0gYXN5bmMgKGFwaSwgY2hhdFJlcXVlc3QsIG11dGF0ZSwgbXV0YXRlU3RyZWFtRGF0YSwgZXhpc3RpbmdEYXRhLCBleHRyYU1ldGFkYXRhUmVmLCBtZXNzYWdlc1JlZiwgYWJvcnRDb250cm9sbGVyUmVmLCBnZW5lcmF0ZUlkLCBvbkZpbmlzaCwgb25SZXNwb25zZSwgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgbXV0YXRlKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBmYWxzZSk7XG4gIGNvbnN0IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkID0gc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyA/IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzIDogY2hhdFJlcXVlc3QubWVzc2FnZXMubWFwKFxuICAgICh7IHJvbGUsIGNvbnRlbnQsIG5hbWUsIGZ1bmN0aW9uX2NhbGwsIHRvb2xfY2FsbHMsIHRvb2xfY2FsbF9pZCB9KSA9PiAoe1xuICAgICAgcm9sZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAuLi5uYW1lICE9PSB2b2lkIDAgJiYgeyBuYW1lIH0sXG4gICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsXG4gICAgICB9LFxuICAgICAgLi4udG9vbF9jYWxscyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgdG9vbF9jYWxsc1xuICAgICAgfVxuICAgIH0pXG4gICk7XG4gIGlmICh0eXBlb2YgYXBpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiY29udGVudFwiXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ1aVwiXSA9IGF3YWl0IHVpO1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYXdhaXQgY2FsbENoYXRBcGkoe1xuICAgIGFwaSxcbiAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQsXG4gICAgYm9keToge1xuICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgLi4uKF9hID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJvZHksXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uczogY2hhdFJlcXVlc3QuZnVuY3Rpb25zXG4gICAgICB9LFxuICAgICAgLi4uY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbFxuICAgICAgfSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LnRvb2xzICE9PSB2b2lkIDAgJiYge1xuICAgICAgICB0b29sczogY2hhdFJlcXVlc3QudG9vbHNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC50b29sX2Nob2ljZSAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgdG9vbF9jaG9pY2U6IGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlXG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uKF9iID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnNcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBtZXNzYWdlXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi5leGlzdGluZ0RhdGEgfHwgW10sIC4uLmRhdGEgfHwgW11dLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGdlbmVyYXRlSWQgPSBuYW5vaWRcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBpZEtleSA9IGlkICE9IG51bGwgPyBpZCA6IGhvb2tJZDtcbiAgY29uc3QgY2hhdEtleSA9IHR5cGVvZiBhcGkgPT09IFwic3RyaW5nXCIgPyBbYXBpLCBpZEtleV0gOiBpZEtleTtcbiAgY29uc3QgW2luaXRpYWxNZXNzYWdlc0ZhbGxiYWNrXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1IoXG4gICAgW2NoYXRLZXksIFwibWVzc2FnZXNcIl0sXG4gICAgbnVsbCxcbiAgICB7IGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzICE9IG51bGwgPyBpbml0aWFsTWVzc2FnZXMgOiBpbml0aWFsTWVzc2FnZXNGYWxsYmFjayB9XG4gICk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSKFxuICAgIFtjaGF0S2V5LCBcImxvYWRpbmdcIl0sXG4gICAgbnVsbFxuICApO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSKFtjaGF0S2V5LCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCB7IGRhdGE6IGVycm9yID0gdm9pZCAwLCBtdXRhdGU6IHNldEVycm9yIH0gPSB1c2VTV1IoW2NoYXRLZXksIFwiZXJyb3JcIl0sIG51bGwpO1xuICBjb25zdCBtZXNzYWdlc1JlZiA9IHVzZVJlZihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHlcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICBhcGksXG4gICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICBzdHJlYW1EYXRhLFxuICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHNcbiAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdDogKGNoYXRSZXF1ZXN0UGFyYW0pID0+IHtcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gY2hhdFJlcXVlc3RQYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gbWVzc2FnZXNSZWYuY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3IoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgZ2VuZXJhdGVJZFxuICAgIF1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG1lc3NhZ2UsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmdW5jdGlvbnMsXG4gICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sX2Nob2ljZSxcbiAgICAgIGRhdGFcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9LFxuICAgICAgICAuLi50b29scyAhPT0gdm9pZCAwICYmIHsgdG9vbHMgfSxcbiAgICAgICAgLi4udG9vbF9jaG9pY2UgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2hvaWNlIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkXVxuICApO1xuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoe1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29scyxcbiAgICAgIHRvb2xfY2hvaWNlXG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1JlZi5jdXJyZW50W21lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIikge1xuICAgICAgICBjb25zdCBjaGF0UmVxdWVzdDIgPSB7XG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbl9jYWxsIH0sXG4gICAgICAgICAgLi4udG9vbHMgIT09IHZvaWQgMCAmJiB7IHRvb2xzIH0sXG4gICAgICAgICAgLi4udG9vbF9jaG9pY2UgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2hvaWNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0Mik7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSxcbiAgICAgICAgLi4udG9vbHMgIT09IHZvaWQgMCAmJiB7IHRvb2xzIH0sXG4gICAgICAgIC4uLnRvb2xfY2hvaWNlICE9PSB2b2lkIDAgJiYgeyB0b29sX2Nob2ljZSB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzMiwgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzMjtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGUsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCBhcyB1c2VJZDIsIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IyIGZyb20gXCJzd3JcIjtcblxuLy8gc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgb25EYXRhXG59KSB7XG4gIHRyeSB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcbiAgICBzZXRDb21wbGV0aW9uKFwiXCIpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9KSxcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgfSxcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYXdhaXQgcmVzLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXMuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzLmhlYWRlcnMuZ2V0KENPTVBMRVhfSEVBREVSKSA9PT0gXCJ0cnVlXCI7XG4gICAgaWYgKGlzQ29tcGxleE1vZGUpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgICAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlciA9PT0gbnVsbFxuICAgICAgfSkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5mdW5jdGlvbiB1c2VDb21wbGV0aW9uKHtcbiAgYXBpID0gXCIvYXBpL2NvbXBsZXRpb25cIixcbiAgaWQsXG4gIGluaXRpYWxDb21wbGV0aW9uID0gXCJcIixcbiAgaW5pdGlhbElucHV0ID0gXCJcIixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yXG59ID0ge30pIHtcbiAgY29uc3QgaG9va0lkID0gdXNlSWQyKCk7XG4gIGNvbnN0IGNvbXBsZXRpb25JZCA9IGlkIHx8IGhvb2tJZDtcbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjIoW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb25cbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSMihcbiAgICBbY29tcGxldGlvbklkLCBcImxvYWRpbmdcIl0sXG4gICAgbnVsbFxuICApO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSMihbY29tcGxldGlvbklkLCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlMih2b2lkIDApO1xuICBjb25zdCBjb21wbGV0aW9uID0gZGF0YTtcbiAgY29uc3QgW2Fib3J0Q29udHJvbGxlciwgc2V0QWJvcnRDb250cm9sbGVyXSA9IHVzZVN0YXRlMihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZjIoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICBhcGksXG4gICAgICBwcm9tcHQsXG4gICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogeyAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycywgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzIH0sXG4gICAgICBib2R5OiB7XG4gICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHlcbiAgICAgIH0sXG4gICAgICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjIpID0+IG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpLFxuICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgIHNldEVycm9yLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uRGF0YTogKGRhdGEyKSA9PiB7XG4gICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLnN0cmVhbURhdGEgfHwgW10sIC4uLmRhdGEyIHx8IFtdXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIG11dGF0ZVN0cmVhbURhdGFcbiAgICBdXG4gICk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2syKFxuICAgIChjb21wbGV0aW9uMikgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZTIoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2syKFxuICAgIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICByZXR1cm4gY29tcGxldGUoaW5wdXQpO1xuICAgIH0sXG4gICAgW2lucHV0LCBjb21wbGV0ZV1cbiAgKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0aW9uLFxuICAgIGNvbXBsZXRlLFxuICAgIGVycm9yLFxuICAgIHNldENvbXBsZXRpb24sXG4gICAgc3RvcCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGFcbiAgfTtcbn1cblxuLy8gcmVhY3QvdXNlLWFzc2lzdGFudC50c1xuaW1wb3J0IHsgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50KHtcbiAgYXBpLFxuICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTMoW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlMyhcIlwiKTtcbiAgY29uc3QgW3RocmVhZElkLCBzZXRUaHJlYWRJZF0gPSB1c2VTdGF0ZTModm9pZCAwKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlMyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUzKHZvaWQgMCk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgc2V0SW5wdXQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChldmVudCwgcmVxdWVzdE9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZXZlbnQpO1xuICAgIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTdGF0dXMoXCJpbl9wcm9ncmVzc1wiKTtcbiAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiBbXG4gICAgICAuLi5tZXNzYWdlczIsXG4gICAgICB7IGlkOiBcIlwiLCByb2xlOiBcInVzZXJcIiwgY29udGVudDogaW5wdXQgfVxuICAgIF0pO1xuICAgIHNldElucHV0KFwiXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4uaGVhZGVycyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAuLi5ib2R5LFxuICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgIHRocmVhZElkOiAoX2IgPSB0aHJlYWRJZFBhcmFtICE9IG51bGwgPyB0aHJlYWRJZFBhcmFtIDogdGhyZWFkSWQpICE9IG51bGwgPyBfYiA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuICAgICAgICAvLyBvcHRpb25hbCByZXF1ZXN0IGRhdGE6XG4gICAgICAgIGRhdGE6IHJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiByZXF1ZXN0T3B0aW9ucy5kYXRhXG4gICAgICB9KVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShcbiAgICAgICAgcmVzdWx0LmJvZHkuZ2V0UmVhZGVyKClcbiAgICAgICkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9tZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMyLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgIHJvbGU6IHZhbHVlLnJvbGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudFswXS50ZXh0LnZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkYXRhX21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VzMixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9hMiA9IHZhbHVlLmlkKSAhPSBudWxsID8gX2EyIDogXCJcIixcbiAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMyW21lc3NhZ2VzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ubWVzc2FnZXMyLnNsaWNlKDAsIG1lc3NhZ2VzMi5sZW5ndGggLSAxKSwgbGFzdE1lc3NhZ2VdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gbmV3IEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVycm9yT2JqKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgICAgc2V0RXJyb3IoZXJyb3IyKTtcbiAgICB9XG4gICAgc2V0U3RhdHVzKFwiYXdhaXRpbmdfbWVzc2FnZVwiKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICB0aHJlYWRJZCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBzdWJtaXRNZXNzYWdlLFxuICAgIHN0YXR1cyxcbiAgICBlcnJvclxuICB9O1xufVxuZXhwb3J0IHtcbiAgZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCxcbiAgdXNlQ2hhdCxcbiAgdXNlQ29tcGxldGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwidmFsdWUiLCJFcnJvciIsInR5cGUiLCJmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0IiwiZnVuY3Rpb25fY2FsbCIsImFyZ3VtZW50cyIsImRhdGFTdHJlYW1QYXJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJtYXAiLCJwYXJ0IiwicGFyc2VTdHJlYW1QYXJ0IiwibGluZSIsImZpcnN0U2VwYXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwicHVzaCIsInN0cmVhbVBhcnRzMiIsImRlY29kZSIsInN0cmVhbSIsInNwbGl0IiwiZmlsdGVyIiwic3RyZWFtUGFydCIsImNhbmNlbCIsImN1c3RvbUFscGhhYmV0IiwibmFub2lkIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZWQiLCJCb29sZWFuIiwiQ09NUExFWF9IRUFERVIiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZW5lcmF0ZUlkIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiY3JlYXRlZEF0IiwicHJlZml4TWFwIiwiZGF0YSIsIm1lc3NhZ2VfYW5ub3RhdGlvbnMiLCJjdXJyZW50IiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInRvb2xDYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lc3NhZ2VQcmVmaXhLZXlzIiwiZm9yRWFjaCIsImtleSIsIm1lcmdlZCIsIm1lc3NhZ2VzIiwiY2FsbENoYXRBcGkiLCJhcGkiLCJib2R5IiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwiYXBwZW5kTWVzc2FnZSIsInJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSIsIm9uUmVzcG9uc2UiLCJvblVwZGF0ZSIsIl9hIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsInN0cmluZ2lmeSIsInNpZ25hbCIsImNhdGNoIiwiZXJyIiwib2siLCJnZXRSZWFkZXIiLCJpc0NvbXBsZXhNb2RlIiwiZ2V0Iiwic3RyZWFtZWRSZXNwb25zZSIsInJlcGx5SWQiLCJkb25lIiwic3RhcnRzV2l0aCIsInBhcnNlZEZ1bmN0aW9uQ2FsbCIsInBhcnNlZFRvb2xDYWxscyIsInByb2Nlc3NDaGF0U3RyZWFtIiwiZ2V0U3RyZWFtZWRSZXNwb25zZSIsImdldFN0cmVhbWVkUmVzcG9uc2UyIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbCIsImNvbnNvbGUiLCJ3YXJuIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2UiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsUmVzcG9uc2UiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyIiwiZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzIiwic3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UiLCJjaGF0UmVxdWVzdCIsIm11dGF0ZSIsIm11dGF0ZVN0cmVhbURhdGEiLCJleGlzdGluZ0RhdGEiLCJleHRyYU1ldGFkYXRhUmVmIiwibWVzc2FnZXNSZWYiLCJzZW5kRXh0cmFNZXNzYWdlRmllbGRzIiwiX2IiLCJwcmV2aW91c01lc3NhZ2VzIiwiY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQiLCJ0b29sX2NhbGxfaWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsImNoYXRSZXF1ZXN0MiIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwibWVzc2FnZXMyIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VJZDIiLCJ1c2VSZWYyIiwidXNlU3RhdGUyIiwidXNlU1dSMiIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJyZXN1bHQiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGlvbjIiLCJkYXRhMiIsImNvbXBsZXRlIiwidXNlU3RhdGUzIiwiZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImV2ZW50Iiwic3VibWl0TWVzc2FnZSIsInJlcXVlc3RPcHRpb25zIiwiY2FsbCIsIl9hMiIsImVycm9yT2JqIiwiZXJyb3IyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13/node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13/node_modules/ai/dist/index.mjs":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13/node_modules/ai/dist/index.mjs ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   COMPLEX_HEADER: () => (/* binding */ COMPLEX_HEADER),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/.pnpm/nanoid@3.3.6/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/.pnpm/eventsource-parser@1.0.0/node_modules/eventsource-parser/dist/index.js\");\n// shared/utils.ts\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar isStreamStringEqualToType = (type, value)=>value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_1__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            controller.enqueue(textEncoder.encode(message));\n            aggregatedResponse += message;\n            if (callbacks.onToken) await callbacks.onToken(message);\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nvar experimental_StreamData = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        // closing the stream is synchronous, but we want to return a promise\n        // in case we're doing async work\n        this.isClosedPromise = null;\n        this.isClosedPromiseResolver = void 0;\n        this.isClosed = false;\n        // array to store appended data\n        this.data = [];\n        this.messageAnnotations = [];\n        this.isClosedPromise = new Promise((resolve)=>{\n            this.isClosedPromiseResolver = resolve;\n        });\n        const self = this;\n        this.stream = new TransformStream({\n            start: async (controller)=>{\n                self.controller = controller;\n            },\n            transform: async (chunk, controller)=>{\n                if (self.data.length > 0) {\n                    const encodedData = self.encoder.encode(formatStreamPart(\"data\", self.data));\n                    self.data = [];\n                    controller.enqueue(encodedData);\n                }\n                if (self.messageAnnotations.length) {\n                    const encodedMessageAnnotations = self.encoder.encode(formatStreamPart(\"message_annotations\", self.messageAnnotations));\n                    self.messageAnnotations = [];\n                    controller.enqueue(encodedMessageAnnotations);\n                }\n                controller.enqueue(chunk);\n            },\n            async flush (controller) {\n                const warningTimeout =  true ? setTimeout(()=>{\n                    console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                }, 3e3) : 0;\n                await self.isClosedPromise;\n                if (warningTimeout !== null) {\n                    clearTimeout(warningTimeout);\n                }\n                if (self.data.length) {\n                    const encodedData = self.encoder.encode(formatStreamPart(\"data\", self.data));\n                    controller.enqueue(encodedData);\n                }\n                if (self.messageAnnotations.length) {\n                    const encodedData = self.encoder.encode(formatStreamPart(\"message_annotations\", self.messageAnnotations));\n                    controller.enqueue(encodedData);\n                }\n            }\n        });\n    }\n    async close() {\n        var _a;\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n        this.isClosed = true;\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        this.data.push(value);\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        this.messageAnnotations.push(value);\n    }\n};\nfunction createStreamDataTransformer(experimental_streamData) {\n    if (!experimental_streamData) {\n        return new TransformStream({\n            transform: async (chunk, controller)=>{\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n    let previous = \"\";\n    return (data)=>{\n        const json = JSON.parse(data);\n        if (\"error\" in json) {\n            throw new Error(`${json.error.type}: ${json.error.message}`);\n        }\n        if (!(\"completion\" in json)) {\n            return;\n        }\n        const text = json.completion;\n        if (!previous || text.length > previous.length && text.startsWith(previous)) {\n            const delta = text.slice(previous.length);\n            previous = text;\n            return delta;\n        }\n        return text;\n    };\n}\nasync function* streamable(stream) {\n    for await (const chunk of stream){\n        if (\"completion\" in chunk) {\n            const text = chunk.completion;\n            if (text) yield text;\n        } else if (\"delta\" in chunk) {\n            const { delta } = chunk;\n            if (\"text\" in delta) {\n                const text = delta.text;\n                if (text) yield text;\n            }\n        }\n    }\n}\nfunction AnthropicStream(res, cb) {\n    if (Symbol.asyncIterator in res) {\n        return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    } else {\n        return AIStream(res, parseAnthropicStream(), cb).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    }\n}\n// streams/assistant-response.ts\nfunction experimental_AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"error\", errorMessage)));\n            };\n            controller.enqueue(textEncoder.encode(formatStreamPart(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    threadId,\n                    messageId,\n                    sendMessage,\n                    sendDataMessage\n                });\n            } catch (error) {\n                sendError((_a = error.message) != null ? _a : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n    var _a, _b;\n    const decoder = new TextDecoder();\n    for await (const chunk of (_a = response.body) != null ? _a : []){\n        const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n        if (bytes != null) {\n            const chunkText = decoder.decode(bytes);\n            const chunkJSON = JSON.parse(chunkText);\n            const delta = extractTextDeltaFromChunk(chunkJSON);\n            if (delta != null) {\n                yield delta;\n            }\n        }\n    }\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, // As of 2023-11-17, Bedrock does not support streaming for Cohere,\n    // so we take the full generation:\n    (chunk)=>{\n        var _a, _b;\n        return (_b = (_a = chunk.generations) == null ? void 0 : _a[0]) == null ? void 0 : _b.text;\n    });\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n    return readableFromAsyncIterable(asDeltaIterable(response, extractTextDeltaFromChunk)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n    for (const line of lines){\n        const { text, is_finished } = JSON.parse(line);\n        if (!is_finished) {\n            controller.enqueue(text);\n        }\n    }\n}\nasync function readAndProcessLines(reader, controller) {\n    let segment = \"\";\n    while(true){\n        const { value: chunk, done } = await reader.read();\n        if (done) {\n            break;\n        }\n        segment += utf8Decoder.decode(chunk, {\n            stream: true\n        });\n        const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n        segment = linesArray.pop() || \"\";\n        await processLines(linesArray, controller);\n    }\n    if (segment) {\n        const linesArray = [\n            segment\n        ];\n        await processLines(linesArray, controller);\n    }\n    controller.close();\n}\nfunction createParser2(res) {\n    var _a;\n    const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n    return new ReadableStream({\n        async start (controller) {\n            if (!reader) {\n                controller.close();\n                return;\n            }\n            await readAndProcessLines(reader, controller);\n        }\n    });\n}\nasync function* streamable2(stream) {\n    for await (const chunk of stream){\n        if (chunk.eventType === \"text-generation\") {\n            const text = chunk.text;\n            if (text) yield text;\n        }\n    }\n}\nfunction CohereStream(reader, callbacks) {\n    if (Symbol.asyncIterator in reader) {\n        return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n    } else {\n        return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n    }\n}\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n    var _a, _b, _c;\n    for await (const chunk of response.stream){\n        const parts = (_c = (_b = (_a = chunk.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n        if (parts === void 0) {\n            continue;\n        }\n        const firstPart = parts[0];\n        if (typeof firstPart.text === \"string\") {\n            yield firstPart.text;\n        }\n    }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n    return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n}\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a, _b;\n            const { value, done } = await res.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n            if (!text) return;\n            if (value.generated_text != null && value.generated_text.length > 0) {\n                return;\n            }\n            if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n                return;\n            }\n            controller.enqueue(text);\n        }\n    });\n}\nfunction HuggingFaceStream(res, callbacks) {\n    return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n    if (!res.body) {\n        throw new Error(\"Response body is null\");\n    }\n    let chat_session_id = \"\";\n    let records_cited;\n    const inkeepEventParser = (data, options)=>{\n        var _a, _b;\n        const { event } = options;\n        if (event === \"records_cited\") {\n            records_cited = JSON.parse(data);\n            (_a = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a.call(callbacks, records_cited);\n        }\n        if (event === \"message_chunk\") {\n            const inkeepMessageChunk = JSON.parse(data);\n            chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n            return inkeepMessageChunk.content_chunk;\n        }\n        return;\n    };\n    let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n    passThroughCallbacks = {\n        ...passThroughCallbacks,\n        onFinal: (completion)=>{\n            var _a;\n            const inkeepOnFinalMetadata = {\n                chat_session_id,\n                records_cited\n            };\n            (_a = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a.call(callbacks, completion, inkeepOnFinalMetadata);\n        }\n    };\n    return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(createStreamDataTransformer(passThroughCallbacks == null ? void 0 : passThroughCallbacks.experimental_streamData));\n}\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const runs = /* @__PURE__ */ new Set();\n    const handleError = async (e, runId)=>{\n        runs.delete(runId);\n        await writer.ready;\n        await writer.abort(e);\n    };\n    const handleStart = async (runId)=>{\n        runs.add(runId);\n    };\n    const handleEnd = async (runId)=>{\n        runs.delete(runId);\n        if (runs.size === 0) {\n            await writer.ready;\n            await writer.close();\n        }\n    };\n    return {\n        stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)),\n        writer,\n        handlers: {\n            handleLLMNewToken: async (token)=>{\n                await writer.ready;\n                await writer.write(token);\n            },\n            handleLLMStart: async (_llm, _prompts, runId)=>{\n                handleStart(runId);\n            },\n            handleLLMEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleLLMError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleChainStart: async (_chain, _inputs, runId)=>{\n                handleStart(runId);\n            },\n            handleChainEnd: async (_outputs, runId)=>{\n                await handleEnd(runId);\n            },\n            handleChainError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleToolStart: async (_tool, _input, runId)=>{\n                handleStart(runId);\n            },\n            handleToolEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleToolError: async (e, runId)=>{\n                await handleError(e, runId);\n            }\n        }\n    };\n}\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n    var _a, _b;\n    for await (const chunk of stream){\n        const content = (_b = (_a = chunk.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.content;\n        if (content === void 0 || content === \"\") {\n            continue;\n        }\n        yield content;\n    }\n}\nfunction MistralStream(response, callbacks) {\n    const stream = readableFromAsyncIterable(streamable4(response));\n    return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData));\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`;\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`;\n                } else {\n                    return `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`;\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments);\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments);\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return '\"}}';\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return '\"}}]}';\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const isComplexMode = callbacks == null ? void 0 : callbacks.experimental_streamData;\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(isComplexMode ? textEncoder.encode(formatStreamPart(\"text\", message)) : chunk);\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: tool.function.arguments\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(isComplexMode ? formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse)) : aggregatedResponse));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(isComplexMode ? textEncoder.encode(formatStreamPart(\"text\", functionResponse)) : textEncoder.encode(functionResponse));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n    var _a;\n    const url = (_a = res.urls) == null ? void 0 : _a.stream;\n    if (!url) {\n        if (res.error) throw new Error(res.error);\n        else throw new Error(\"Missing stream URL in Replicate response\");\n    }\n    const eventStream = await fetch(url, {\n        method: \"GET\",\n        headers: {\n            Accept: \"text/event-stream\",\n            ...options == null ? void 0 : options.headers\n        }\n    });\n    return AIStream(eventStream, void 0, cb).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n}\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n    constructor(res, options){\n        var _a;\n        let resolveFunc = ()=>{};\n        let next = new Promise((resolve)=>{\n            resolveFunc = resolve;\n        });\n        if (options == null ? void 0 : options.data) {\n            const processedStream = res.pipeThrough(options.data.stream);\n            let lastPayload = void 0;\n            parseComplexResponse({\n                reader: processedStream.getReader(),\n                update: (merged, data)=>{\n                    var _a2, _b, _c;\n                    const content2 = (_b = (_a2 = merged[0]) == null ? void 0 : _a2.content) != null ? _b : \"\";\n                    const ui = ((_c = options == null ? void 0 : options.ui) == null ? void 0 : _c.call(options, {\n                        content: content2,\n                        data\n                    })) || content2;\n                    const payload = {\n                        ui,\n                        content: content2\n                    };\n                    const resolvePrevious = resolveFunc;\n                    const nextRow = new Promise((resolve)=>{\n                        resolveFunc = resolve;\n                    });\n                    resolvePrevious({\n                        next: nextRow,\n                        ...payload\n                    });\n                    lastPayload = payload;\n                },\n                generateId: (_a = options.generateId) != null ? _a : nanoid,\n                onFinish: ()=>{\n                    if (lastPayload !== void 0) {\n                        resolveFunc({\n                            next: null,\n                            ...lastPayload\n                        });\n                    }\n                }\n            });\n            return next;\n        }\n        let content = \"\";\n        const decode = createChunkDecoder();\n        const reader = res.getReader();\n        async function readChunk() {\n            var _a2;\n            const { done, value } = await reader.read();\n            if (!done) {\n                content += decode(value);\n            }\n            const ui = ((_a2 = options == null ? void 0 : options.ui) == null ? void 0 : _a2.call(options, {\n                content\n            })) || content;\n            const payload = {\n                ui,\n                content\n            };\n            const resolvePrevious = resolveFunc;\n            const nextRow = done ? null : new Promise((resolve)=>{\n                resolveFunc = resolve;\n            });\n            resolvePrevious({\n                next: nextRow,\n                ...payload\n            });\n            if (done) {\n                return;\n            }\n            await readChunk();\n        }\n        readChunk();\n        return next;\n    }\n};\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n    constructor(res, init, data){\n        let processedStream = res;\n        if (data) {\n            processedStream = res.pipeThrough(data.stream);\n        }\n        super(processedStream, {\n            ...init,\n            status: 200,\n            headers: {\n                \"Content-Type\": \"text/plain; charset=utf-8\",\n                [COMPLEX_HEADER]: data ? \"true\" : \"false\",\n                ...init == null ? void 0 : init.headers\n            }\n        });\n    }\n};\nfunction streamToResponse(res, response, init) {\n    response.writeHead((init == null ? void 0 : init.status) || 200, {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n    });\n    const reader = res.getReader();\n    function read() {\n        reader.read().then(({ done, value })=>{\n            if (done) {\n                response.end();\n                return;\n            }\n            response.write(value);\n            read();\n        });\n    }\n    read();\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMi4yLjM3X3JlYWN0QDE4LjMuMV9zb2xpZC1qc0AxLjkuNl9zdmVsdGVANC4yLjE5X3Z1ZUAzLjUuMTMvbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtCQUFrQjtBQUNpQztBQUVuRCx5QkFBeUI7QUFDekIsSUFBSUMsaUJBQWlCO0lBQ25CQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJRyx5QkFBeUI7SUFDM0JOLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLG9CQUFtQkEsS0FBSSxLQUFNLE9BQU9BLE1BQU1JLGFBQWEsS0FBSyxZQUFZSixNQUFNSSxhQUFhLElBQUksUUFBUSxDQUFFLFdBQVVKLE1BQU1JLGFBQWEsS0FBSyxDQUFFLGdCQUFlSixNQUFNSSxhQUFhLEtBQUssT0FBT0osTUFBTUksYUFBYSxDQUFDTixJQUFJLEtBQUssWUFBWSxPQUFPRSxNQUFNSSxhQUFhLENBQUNDLFNBQVMsS0FBSyxVQUFVO1lBQ3pVLE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05GO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSU0saUJBQWlCO0lBQ25CVCxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksQ0FBQ08sTUFBTUMsT0FBTyxDQUFDUixRQUFRO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lB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UUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS3ZNLE9BQU87WUFDekM7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTd00saUJBQWlCak4sR0FBRyxFQUFFekQsUUFBUSxFQUFFeVEsSUFBSTtJQUMzQ3pRLFNBQVMyUSxTQUFTLENBQUMsQ0FBQ0YsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS3hNLE1BQU0sS0FBSyxLQUFLO1FBQy9ELGdCQUFnQjtRQUNoQixHQUFHd00sUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS3ZNLE9BQU87SUFDekM7SUFDQSxNQUFNL0QsU0FBU3NELElBQUlyRCxTQUFTO0lBQzVCLFNBQVNHO1FBQ1BKLE9BQU9JLElBQUksR0FBR3FRLElBQUksQ0FBQyxDQUFDLEVBQUV0USxJQUFJLEVBQUV2RyxLQUFLLEVBQUU7WUFDakMsSUFBSXVHLE1BQU07Z0JBQ1JOLFNBQVM2USxHQUFHO2dCQUNaO1lBQ0Y7WUFDQTdRLFNBQVNtSSxLQUFLLENBQUNwTztZQUNmd0c7UUFDRjtJQUNGO0lBQ0FBO0FBQ0Y7QUE4QkUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnRlcnZpZXcvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMi4yLjM3X3JlYWN0QDE4LjMuMV9zb2xpZC1qc0AxLjkuNl9zdmVsdGVANC4yLjE5X3Z1ZUAzLjUuMTMvbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzP2M0ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hhcmVkL3V0aWxzLnRzXG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xuXG4vLyBzaGFyZWQvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI3XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sX2NhbGxzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fCB2YWx1ZS50b29sX2NhbGxzLnNvbWUoKHRjKSA9PiB7XG4gICAgICB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCI7XG4gICAgfSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxzXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG59O1xudmFyIFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xudmFyIG5hbm9pZCA9IGN1c3RvbUFscGhhYmV0KFxuICBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIDdcbik7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKHR5cGUsIHZhbHVlKSA9PiB2YWx1ZS5zdGFydHNXaXRoKGAke1N0cmVhbVN0cmluZ1ByZWZpeGVzW3R5cGVdfTpgKSAmJiB2YWx1ZS5lbmRzV2l0aChcIlxcblwiKTtcbnZhciBDT01QTEVYX0hFQURFUiA9IFwiWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGFcIjtcblxuLy8gc3RyZWFtcy9haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlclxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiIHx8IC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgICB9KSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShtZXNzYWdlKSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4obWVzc2FnZSk7XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgYXdhaXQgKChfYSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbnZhciBleHBlcmltZW50YWxfU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICAvLyBjbG9zaW5nIHRoZSBzdHJlYW0gaXMgc3luY2hyb25vdXMsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiBhIHByb21pc2VcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIGRvaW5nIGFzeW5jIHdvcmtcbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgLy8gYXJyYXkgdG8gc3RvcmUgYXBwZW5kZWQgZGF0YVxuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zID0gW107XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlQW5ub3RhdGlvbnMgPSBzZWxmLmVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ1RpbWVvdXQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sIDNlMykgOiBudWxsO1xuICAgICAgICBhd2FpdCBzZWxmLmlzQ2xvc2VkUHJvbWlzZTtcbiAgICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHNlbGYubWVzc2FnZUFubm90YXRpb25zKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlQW5ub3RhdGlvbnMucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpIHtcbiAgaWYgKCFleHBlcmltZW50YWxfc3RyZWFtRGF0YSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBtZXNzYWdlKSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvYW50aHJvcGljLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VBbnRocm9waWNTdHJlYW0oKSB7XG4gIGxldCBwcmV2aW91cyA9IFwiXCI7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChcImVycm9yXCIgaW4ganNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2pzb24uZXJyb3IudHlwZX06ICR7anNvbi5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBpZiAoIShcImNvbXBsZXRpb25cIiBpbiBqc29uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0ganNvbi5jb21wbGV0aW9uO1xuICAgIGlmICghcHJldmlvdXMgfHwgdGV4dC5sZW5ndGggPiBwcmV2aW91cy5sZW5ndGggJiYgdGV4dC5zdGFydHNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0ZXh0LnNsaWNlKHByZXZpb3VzLmxlbmd0aCk7XG4gICAgICBwcmV2aW91cyA9IHRleHQ7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwiY29tcGxldGlvblwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH0gZWxzZSBpZiAoXCJkZWx0YVwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB7IGRlbHRhIH0gPSBjaHVuaztcbiAgICAgIGlmIChcInRleHRcIiBpbiBkZWx0YSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZGVsdGEudGV4dDtcbiAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfc3RyZWFtRGF0YSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBSVN0cmVhbShyZXMsIHBhcnNlQW50aHJvcGljU3RyZWFtKCksIGNiKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2Fzc2lzdGFudC1yZXNwb25zZS50c1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlKHsgdGhyZWFkSWQsIG1lc3NhZ2VJZCB9LCBwcm9jZXNzMikge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZW5kRXJyb3IoKF9hID0gZXJyb3IubWVzc2FnZSkgIT0gbnVsbCA/IF9hIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9hd3MtYmVkcm9jay1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIChfYSA9IHJlc3BvbnNlLmJvZHkpICE9IG51bGwgPyBfYSA6IFtdKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoX2IgPSBjaHVuay5jaHVuaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJ5dGVzO1xuICAgIGlmIChieXRlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVua1RleHQgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBjaHVua0pTT04gPSBKU09OLnBhcnNlKGNodW5rVGV4dCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsoY2h1bmtKU09OKTtcbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIGRlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuY29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0oXG4gICAgcmVzcG9uc2UsXG4gICAgY2FsbGJhY2tzLFxuICAgIC8vIEFzIG9mIDIwMjMtMTEtMTcsIEJlZHJvY2sgZG9lcyBub3Qgc3VwcG9ydCBzdHJlYW1pbmcgZm9yIENvaGVyZSxcbiAgICAvLyBzbyB3ZSB0YWtlIHRoZSBmdWxsIGdlbmVyYXRpb246XG4gICAgKGNodW5rKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGNodW5rLmdlbmVyYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi50ZXh0O1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmdlbmVyYXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKFxuICAgIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaylcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMihyZXMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUyKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChjaHVuay5ldmVudFR5cGUgPT09IFwidGV4dC1nZW5lcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0O1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDb2hlcmVTdHJlYW0ocmVhZGVyLCBjYWxsYmFja3MpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlYWRlcikge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUyKHJlYWRlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVhZGVyKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgICApO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvZ29vZ2xlLWdlbmVyYXRpdmUtYWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTMocmVzcG9uc2UpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgY29uc3QgcGFydHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucGFydHM7XG4gICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0UGFydC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB5aWVsZCBmaXJzdFBhcnQudGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbShyZXNwb25zZSwgY2IpIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTMocmVzcG9uc2UpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpKTtcbn1cblxuLy8gc3RyZWFtcy9odWdnaW5nZmFjZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjMocmVzKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0ZWRfdGV4dCAhPSBudWxsICYmIHZhbHVlLmdlbmVyYXRlZF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjMocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvaW5rZWVwLXN0cmVhbS50c1xuZnVuY3Rpb24gSW5rZWVwU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIik7XG4gIH1cbiAgbGV0IGNoYXRfc2Vzc2lvbl9pZCA9IFwiXCI7XG4gIGxldCByZWNvcmRzX2NpdGVkO1xuICBjb25zdCBpbmtlZXBFdmVudFBhcnNlciA9IChkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGV2ZW50IH0gPSBvcHRpb25zO1xuICAgIGlmIChldmVudCA9PT0gXCJyZWNvcmRzX2NpdGVkXCIpIHtcbiAgICAgIHJlY29yZHNfY2l0ZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgKF9hID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcywgcmVjb3Jkc19jaXRlZCk7XG4gICAgfVxuICAgIGlmIChldmVudCA9PT0gXCJtZXNzYWdlX2NodW5rXCIpIHtcbiAgICAgIGNvbnN0IGlua2VlcE1lc3NhZ2VDaHVuayA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICBjaGF0X3Nlc3Npb25faWQgPSAoX2IgPSBpbmtlZXBNZXNzYWdlQ2h1bmsuY2hhdF9zZXNzaW9uX2lkKSAhPSBudWxsID8gX2IgOiBjaGF0X3Nlc3Npb25faWQ7XG4gICAgICByZXR1cm4gaW5rZWVwTWVzc2FnZUNodW5rLmNvbnRlbnRfY2h1bms7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcbiAgbGV0IHsgb25SZWNvcmRzQ2l0ZWQsIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzIH0gPSBjYWxsYmFja3MgfHwge307XG4gIHBhc3NUaHJvdWdoQ2FsbGJhY2tzID0ge1xuICAgIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzLFxuICAgIG9uRmluYWw6IChjb21wbGV0aW9uKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEgPSB7XG4gICAgICAgIGNoYXRfc2Vzc2lvbl9pZCxcbiAgICAgICAgcmVjb3Jkc19jaXRlZFxuICAgICAgfTtcbiAgICAgIChfYSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcywgY29tcGxldGlvbiwgaW5rZWVwT25GaW5hbE1ldGFkYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBSVN0cmVhbShyZXMsIGlua2VlcEV2ZW50UGFyc2VyLCBwYXNzVGhyb3VnaENhbGxiYWNrcykucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKHBhc3NUaHJvdWdoQ2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBwYXNzVGhyb3VnaENhbGxiYWNrcy5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3MuZXhwZXJpbWVudGFsX3N0cmVhbURhdGEpXG4gICAgKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvbWlzdHJhbC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNChzdHJlYW0pIHtcbiAgdmFyIF9hLCBfYjtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hID0gY2h1bmsuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwIHx8IGNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBjb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiBNaXN0cmFsU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNChyZXNwb25zZSkpO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcihjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiAoZGF0YSkgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNShzdHJlYW0pIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcInByb21wdEZpbHRlclJlc3VsdHNcIiBpbiBjaHVuaykge1xuICAgICAgY2h1bmsgPSB7XG4gICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgY3JlYXRlZDogY2h1bmsuY3JlYXRlZC5nZXREYXRlKCksXG4gICAgICAgIG9iamVjdDogY2h1bmsub2JqZWN0LFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgbW9kZWw6IGNodW5rLm1vZGVsLFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgY2hvaWNlczogY2h1bmsuY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgICAgY29udGVudDogKF9hID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGVudCxcbiAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogKF9iID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgICByb2xlOiAoX2MgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yb2xlLFxuICAgICAgICAgICAgICB0b29sX2NhbGxzOiAoKF9lID0gKF9kID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2QudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UubGVuZ3RoKSA/IChfZyA9IChfZiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZVxuICAgICAgICAgICAgICB9KSkgOiB2b2lkIDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgaW5kZXg6IGNob2ljZS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gZXh0cmFjdChjaHVuayk7XG4gICAgaWYgKHRleHQpXG4gICAgICB5aWVsZCB0ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBjaHVua1RvVGV4dCgpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luO1xuICByZXR1cm4gKGpzb24pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfcjtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IChfYSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbHRhO1xuICAgICAgaWYgKChfYiA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYDtcbiAgICAgIH0gZWxzZSBpZiAoKF9lID0gKF9kID0gKF9jID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGB7XCJ0b29sX2NhbGxzXCI6WyB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9mID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZi5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9nID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKF9oID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4gY2xlYW51cEFyZ3VtZW50cygoX2kgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSBpZiAoKF9sID0gKF9rID0gKF9qID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2suZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFudXBBcmd1bWVudHMoKF9vID0gKF9uID0gKF9tID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX24uZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfby5hcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKCgoX3AgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcC5maW5pc2hfcmVhc29uKSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIgfHwgKChfcSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9xLmZpbmlzaF9yZWFzb24pID09PSBcInN0b3BcIikpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAnXCJ9fSc7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKF9yID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3IuZmluaXNoX3JlYXNvbikgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gJ1wifX1dfSc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50IDogaXNDb21wbGV0aW9uKGpzb24pID8ganNvbi5jaG9pY2VzWzBdLnRleHQgOiBcIlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cbnZhciBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICBcImludGVybmFsX29wZW5haV9mbl9tZXNzYWdlc1wiXG4pO1xuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcImRlbHRhXCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcInRleHRcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBPcGVuQUlTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgY2IgPSBjYWxsYmFja3M7XG4gIGxldCBzdHJlYW07XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU1KHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYWxsYmFja3MpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSBjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5leHBlcmltZW50YWxfc3RyZWFtRGF0YTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID0gaXNGaXJzdENodW5rICYmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICBpc0NvbXBsZXhNb2RlID8gdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSA6IGNodW5rXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0ge1xuICAgICAgICAgICAgICB0b29sczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiB0b29sLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlSW5kZXggPT09IDAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOlwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBpc0NvbXBsZXhNb2RlID8gZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/IFwiZnVuY3Rpb25fY2FsbFwiIDogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICkgOiBhZ2dyZWdhdGVkUmVzcG9uc2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGlzQ29tcGxleE1vZGUgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgZnVuY3Rpb25SZXNwb25zZSkpIDogdGV4dEVuY29kZXIuZW5jb2RlKGZ1bmN0aW9uUmVzcG9uc2UpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gZnVuY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdm9pZCAwO1xuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvcmVwbGljYXRlLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gUmVwbGljYXRlU3RyZWFtKHJlcywgY2IsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB1cmwgPSAoX2EgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0cmVhbTtcbiAgaWYgKCF1cmwpIHtcbiAgICBpZiAocmVzLmVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdHJlYW0gVVJMIGluIFJlcGxpY2F0ZSByZXNwb25zZVwiKTtcbiAgfVxuICBjb25zdCBldmVudFN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBSVN0cmVhbShldmVudFN0cmVhbSwgdm9pZCAwLCBjYikucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfc3RyZWFtRGF0YSlcbiAgKTtcbn1cblxuLy8gc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBhbm5vdGF0aW9ucykge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkID0gbmFub2lkLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXVxuICB9O1xuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IHZvaWQgMDtcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiAoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGxcbiAgfSkpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbXCJ0ZXh0XCJdKSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwW1widGV4dFwiXS5jb250ZW50IHx8IFwiXCIpICsgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdO1xuICAgIH1cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VfYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5cyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICBcInRvb2xfY2FsbHNcIlxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICBwcmVmaXhNYXBba2V5XS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpXG4gICAgfSkpO1xuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXJlYWN0LXJlc3BvbnNlLnRzXG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcmVzb2x2ZUZ1bmMgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBsZXQgbmV4dCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkge1xuICAgICAgY29uc3QgcHJvY2Vzc2VkU3RyZWFtID0gcmVzLnBpcGVUaHJvdWdoKFxuICAgICAgICBvcHRpb25zLmRhdGEuc3RyZWFtXG4gICAgICApO1xuICAgICAgbGV0IGxhc3RQYXlsb2FkID0gdm9pZCAwO1xuICAgICAgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgICByZWFkZXI6IHByb2Nlc3NlZFN0cmVhbS5nZXRSZWFkZXIoKSxcbiAgICAgICAgdXBkYXRlOiAobWVyZ2VkLCBkYXRhKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQyID0gKF9iID0gKF9hMiA9IG1lcmdlZFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb250ZW50KSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICAgICAgICAgIGNvbnN0IHVpID0gKChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudWkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKG9wdGlvbnMsIHsgY29udGVudDogY29udGVudDIsIGRhdGEgfSkpIHx8IGNvbnRlbnQyO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IHVpLCBjb250ZW50OiBjb250ZW50MiB9O1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmVGdW5jO1xuICAgICAgICAgIGNvbnN0IG5leHRSb3cgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc29sdmVQcmV2aW91cyh7XG4gICAgICAgICAgICBuZXh0OiBuZXh0Um93LFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RQYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZDogKF9hID0gb3B0aW9ucy5nZW5lcmF0ZUlkKSAhPSBudWxsID8gX2EgOiBuYW5vaWQsXG4gICAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKGxhc3RQYXlsb2FkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlc29sdmVGdW5jKHtcbiAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgLi4ubGFzdFBheWxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5nZXRSZWFkZXIoKTtcbiAgICBhc3luYyBmdW5jdGlvbiByZWFkQ2h1bmsoKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICghZG9uZSkge1xuICAgICAgICBjb250ZW50ICs9IGRlY29kZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB1aSA9ICgoX2EyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51aSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jYWxsKG9wdGlvbnMsIHsgY29udGVudCB9KSkgfHwgY29udGVudDtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHVpLFxuICAgICAgICBjb250ZW50XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2ZUZ1bmM7XG4gICAgICBjb25zdCBuZXh0Um93ID0gZG9uZSA/IG51bGwgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyh7XG4gICAgICAgIG5leHQ6IG5leHRSb3csXG4gICAgICAgIC4uLnBheWxvYWRcbiAgICAgIH0pO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVhZENodW5rKCk7XG4gICAgfVxuICAgIHJlYWRDaHVuaygpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59O1xuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy10ZXh0LXJlc3BvbnNlLnRzXG52YXIgU3RyZWFtaW5nVGV4dFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yKHJlcywgaW5pdCwgZGF0YSkge1xuICAgIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHByb2Nlc3NlZFN0cmVhbSA9IHJlcy5waXBlVGhyb3VnaChkYXRhLnN0cmVhbSk7XG4gICAgfVxuICAgIHN1cGVyKHByb2Nlc3NlZFN0cmVhbSwge1xuICAgICAgLi4uaW5pdCxcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgW0NPTVBMRVhfSEVBREVSXTogZGF0YSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLFxuICAgICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0cmVhbVRvUmVzcG9uc2UocmVzLCByZXNwb25zZSwgaW5pdCkge1xuICByZXNwb25zZS53cml0ZUhlYWQoKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSB8fCAyMDAsIHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgfSk7XG4gIGNvbnN0IHJlYWRlciA9IHJlcy5nZXRSZWFkZXIoKTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIHJlYWQoKTtcbiAgICB9KTtcbiAgfVxuICByZWFkKCk7XG59XG5leHBvcnQge1xuICBBSVN0cmVhbSxcbiAgQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbSxcbiAgQVdTQmVkcm9ja0NvaGVyZVN0cmVhbSxcbiAgQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSxcbiAgQVdTQmVkcm9ja1N0cmVhbSxcbiAgQW50aHJvcGljU3RyZWFtLFxuICBDT01QTEVYX0hFQURFUixcbiAgQ29oZXJlU3RyZWFtLFxuICBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBJbmtlZXBTdHJlYW0sXG4gIExhbmdDaGFpblN0cmVhbSxcbiAgTWlzdHJhbFN0cmVhbSxcbiAgT3BlbkFJU3RyZWFtLFxuICBSZXBsaWNhdGVTdHJlYW0sXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcixcbiAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyLFxuICBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhLFxuICBleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSxcbiAgaXNTdHJlYW1TdHJpbmdFcXVhbFRvVHlwZSxcbiAgbmFub2lkLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1Ub1Jlc3BvbnNlLFxuICB0cmltU3RhcnRPZlN0cmVhbUhlbHBlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiY3VzdG9tQWxwaGFiZXQiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwicm9sZSIsImNvbnRlbnQiLCJldmVyeSIsIml0ZW0iLCJ0ZXh0IiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbFN0cmVhbVBhcnQiLCJ0b29sX2NhbGxzIiwic29tZSIsInRjIiwiZnVuY3Rpb24iLCJtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Iiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsImZvcm1hdFN0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0IiwiZmluZCIsInN0cmluZ2lmeSIsIm5hbm9pZCIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImRlY29kZWQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiQ09NUExFWF9IRUFERVIiLCJjcmVhdGVQYXJzZXIiLCJjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyIiwiY3VzdG9tUGFyc2VyIiwidGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwiZGF0YSIsInRlcm1pbmF0ZSIsInBhcnNlZE1lc3NhZ2UiLCJlbnF1ZXVlIiwidHJhbnNmb3JtIiwiZmVlZCIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tzIiwib25TdGFydCIsIm1lc3NhZ2UiLCJlbmNvZGUiLCJvblRva2VuIiwiZmx1c2giLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsInRyaW1TdGFydCIsIkFJU3RyZWFtIiwicmVzcG9uc2UiLCJvayIsImJvZHkiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsImRvbmUiLCJyZWFkIiwiZXJyb3JUZXh0IiwiZXJyb3IiLCJyZXNwb25zZUJvZHlTdHJlYW0iLCJjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtIiwicGlwZVRocm91Z2giLCJjbG9zZSIsInJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUiLCJpdGVyYWJsZSIsIml0IiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInB1bGwiLCJuZXh0IiwiY2FuY2VsIiwicmVhc29uIiwiX2EiLCJyZXR1cm4iLCJjYWxsIiwiZXhwZXJpbWVudGFsX1N0cmVhbURhdGEiLCJjb25zdHJ1Y3RvciIsImVuY29kZXIiLCJpc0Nsb3NlZFByb21pc2UiLCJpc0Nsb3NlZFByb21pc2VSZXNvbHZlciIsImlzQ2xvc2VkIiwibWVzc2FnZUFubm90YXRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZWxmIiwibGVuZ3RoIiwiZW5jb2RlZERhdGEiLCJlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zIiwid2FybmluZ1RpbWVvdXQiLCJwcm9jZXNzIiwic2V0VGltZW91dCIsImNvbnNvbGUiLCJ3YXJuIiwiY2xlYXJUaW1lb3V0IiwiYXBwZW5kIiwicHVzaCIsImFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uIiwiY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIiwiZXhwZXJpbWVudGFsX3N0cmVhbURhdGEiLCJwYXJzZUFudGhyb3BpY1N0cmVhbSIsInByZXZpb3VzIiwianNvbiIsImNvbXBsZXRpb24iLCJkZWx0YSIsInN0cmVhbWFibGUiLCJBbnRocm9waWNTdHJlYW0iLCJyZXMiLCJleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UiLCJwcm9jZXNzMiIsInNlbmRNZXNzYWdlIiwic2VuZERhdGFNZXNzYWdlIiwic2VuZEVycm9yIiwiZXJyb3JNZXNzYWdlIiwiUmVzcG9uc2UiLCJzdGF0dXMiLCJoZWFkZXJzIiwiYXNEZWx0YUl0ZXJhYmxlIiwiZXh0cmFjdFRleHREZWx0YUZyb21DaHVuayIsIl9iIiwiYnl0ZXMiLCJjaHVua1RleHQiLCJjaHVua0pTT04iLCJBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtIiwiQVdTQmVkcm9ja1N0cmVhbSIsIkFXU0JlZHJvY2tDb2hlcmVTdHJlYW0iLCJnZW5lcmF0aW9ucyIsIkFXU0JlZHJvY2tMbGFtYTJTdHJlYW0iLCJnZW5lcmF0aW9uIiwidXRmOERlY29kZXIiLCJwcm9jZXNzTGluZXMiLCJsaW5lcyIsImlzX2ZpbmlzaGVkIiwicmVhZEFuZFByb2Nlc3NMaW5lcyIsInNlZ21lbnQiLCJsaW5lc0FycmF5IiwicG9wIiwiY3JlYXRlUGFyc2VyMiIsInN0cmVhbWFibGUyIiwiZXZlbnRUeXBlIiwiQ29oZXJlU3RyZWFtIiwic3RyZWFtYWJsZTMiLCJfYyIsInBhcnRzIiwiY2FuZGlkYXRlcyIsImZpcnN0UGFydCIsIkdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSIsImNyZWF0ZVBhcnNlcjMiLCJ0cmltU3RhcnRPZlN0cmVhbSIsInRva2VuIiwiZ2VuZXJhdGVkX3RleHQiLCJIdWdnaW5nRmFjZVN0cmVhbSIsIklua2VlcFN0cmVhbSIsImNoYXRfc2Vzc2lvbl9pZCIsInJlY29yZHNfY2l0ZWQiLCJpbmtlZXBFdmVudFBhcnNlciIsIm9wdGlvbnMiLCJvblJlY29yZHNDaXRlZCIsImlua2VlcE1lc3NhZ2VDaHVuayIsImNvbnRlbnRfY2h1bmsiLCJwYXNzVGhyb3VnaENhbGxiYWNrcyIsImlua2VlcE9uRmluYWxNZXRhZGF0YSIsIkxhbmdDaGFpblN0cmVhbSIsIndyaXRlciIsIndyaXRhYmxlIiwiZ2V0V3JpdGVyIiwicnVucyIsIlNldCIsImhhbmRsZUVycm9yIiwiZSIsInJ1bklkIiwiZGVsZXRlIiwicmVhZHkiLCJhYm9ydCIsImhhbmRsZVN0YXJ0IiwiYWRkIiwiaGFuZGxlRW5kIiwic2l6ZSIsInJlYWRhYmxlIiwiaGFuZGxlcnMiLCJoYW5kbGVMTE1OZXdUb2tlbiIsIndyaXRlIiwiaGFuZGxlTExNU3RhcnQiLCJfbGxtIiwiX3Byb21wdHMiLCJoYW5kbGVMTE1FbmQiLCJfb3V0cHV0IiwiaGFuZGxlTExNRXJyb3IiLCJoYW5kbGVDaGFpblN0YXJ0IiwiX2NoYWluIiwiX2lucHV0cyIsImhhbmRsZUNoYWluRW5kIiwiX291dHB1dHMiLCJoYW5kbGVDaGFpbkVycm9yIiwiaGFuZGxlVG9vbFN0YXJ0IiwiX3Rvb2wiLCJfaW5wdXQiLCJoYW5kbGVUb29sRW5kIiwiaGFuZGxlVG9vbEVycm9yIiwic3RyZWFtYWJsZTQiLCJjaG9pY2VzIiwiTWlzdHJhbFN0cmVhbSIsInBhcnNlT3BlbkFJU3RyZWFtIiwiZXh0cmFjdCIsImNodW5rVG9UZXh0Iiwic3RyZWFtYWJsZTUiLCJjcmVhdGVkIiwiZ2V0RGF0ZSIsIm9iamVjdCIsIm1vZGVsIiwiY2hvaWNlIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJmdW5jdGlvbkNhbGwiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsImluZGV4IiwiZmluaXNoX3JlYXNvbiIsImZpbmlzaFJlYXNvbiIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsIl9oIiwiX2kiLCJfaiIsIl9rIiwiX2wiLCJfbSIsIl9uIiwiX28iLCJfcCIsIl9xIiwiX3IiLCJpc0NoYXRDb21wbGV0aW9uQ2h1bmsiLCJjbGVhbnVwQXJndW1lbnRzIiwiaXNDb21wbGV0aW9uIiwiYXJndW1lbnRDaHVuayIsImVzY2FwZWRQYXJ0aWFsSnNvbiIsInJlcGxhY2UiLCJfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sIiwiT3BlbkFJU3RyZWFtIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiaXNGaXJzdENodW5rIiwiYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJpc0NvbXBsZXhNb2RlIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJhcmd1bWVudHNQYXlsb2FkIiwicmVzdWx0IiwidG9vbHMiLCJ0b29sIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiUmVwbGljYXRlU3RyZWFtIiwidXJsIiwidXJscyIsImV2ZW50U3RyZWFtIiwiZmV0Y2giLCJtZXRob2QiLCJBY2NlcHQiLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsInNldCIsInJlYWREYXRhU3RyZWFtIiwiaXNBYm9ydGVkIiwic3RyZWFtUGFydHMyIiwiYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZW5lcmF0ZUlkIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiY3JlYXRlZEF0IiwicHJlZml4TWFwIiwibWVzc2FnZV9hbm5vdGF0aW9ucyIsImN1cnJlbnQiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwidG9vbENhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVzc2FnZVByZWZpeEtleXMiLCJmb3JFYWNoIiwia2V5IiwibWVyZ2VkIiwibWVzc2FnZXMiLCJleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSIsInJlc29sdmVGdW5jIiwicHJvY2Vzc2VkU3RyZWFtIiwibGFzdFBheWxvYWQiLCJfYTIiLCJjb250ZW50MiIsInVpIiwicmVzb2x2ZVByZXZpb3VzIiwibmV4dFJvdyIsInJlYWRDaHVuayIsIlN0cmVhbWluZ1RleHRSZXNwb25zZSIsImluaXQiLCJzdHJlYW1Ub1Jlc3BvbnNlIiwid3JpdGVIZWFkIiwidGhlbiIsImVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/ai@2.2.37_react@18.3.1_solid-js@1.9.6_svelte@4.2.19_vue@3.5.13/node_modules/ai/dist/index.mjs\n");

/***/ })

};
;